from collections.abc import Mapping, Sequence
import enum
from typing import overload

import numpy


class CameraModel:
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: Transform, arg5: float, arg6: "cv::Size_<int>", /) -> None: ...

    @overload
    def __init__(self, arg0: str, arg1: float, arg2: float, arg3: float, arg4: float, arg5: Transform, arg6: float, arg7: "cv::Size_<int>", /) -> None: ...

    @staticmethod
    def opticalRotation() -> Transform: ...

    def initRectificationMap(self) -> bool: ...

    def isRectificationMapInitialized(self) -> bool: ...

    def isValidForProjection(self) -> bool: ...

    def isValidForReprojection(self) -> bool: ...

    def isValidForRectification(self) -> bool: ...

    def setName(self, arg: str, /) -> None: ...

    def name(self) -> str: ...

    def fx(self) -> float: ...

    def fy(self) -> float: ...

    def cx(self) -> float: ...

    def cy(self) -> float: ...

    def Tx(self) -> float: ...

    def setLocalTransform(self, arg: Transform, /) -> None: ...

    def localTransform(self) -> Transform: ...

    def setImageSize(self, arg: "cv::Size_<int>", /) -> None: ...

    def imageSize(self) -> "cv::Size_<int>": ...

    def imageWidth(self) -> int: ...

    def imageHeight(self) -> int: ...

    def fovX(self) -> float: ...

    def fovY(self) -> float: ...

    def horizontalFOV(self) -> float: ...

    def verticalFOV(self) -> float: ...

    def isFisheye(self) -> bool: ...

    @overload
    def load(self, arg: str, /) -> bool: ...

    @overload
    def load(self, arg0: str, arg1: str, /) -> bool: ...

    def save(self, arg: str, /) -> bool: ...

    def serialize(self) -> list[int]: ...

    def deserialize(self, arg: Sequence[int], /) -> int: ...

    def scaled(self, arg: float, /) -> CameraModel: ...

    def roi(self, arg: "cv::Rect_<int>", /) -> CameraModel: ...

    def project(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, /) -> None: ...

    def inFrame(self, arg0: int, arg1: int, /) -> bool: ...

class LaserScan:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg0: LaserScan, arg1: int, arg2: float, /) -> None: ...

    @overload
    def __init__(self, arg0: numpy.array, arg1: int, arg2: float, arg3: LaserScanFormat, /) -> None: ...

    @overload
    def __init__(self, arg0: LaserScan, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, /) -> None: ...

    @overload
    def __init__(self, arg0: numpy.array, arg1: LaserScanFormat, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, /) -> None: ...

    @staticmethod
    def isScan2d(arg: LaserScanFormat, /) -> bool: ...

    @staticmethod
    def isScanHasNormals(arg: LaserScanFormat, /) -> bool: ...

    @staticmethod
    def isScanHasRGB(arg: LaserScanFormat, /) -> bool: ...

    @staticmethod
    def isScanHasIntensity(arg: LaserScanFormat, /) -> bool: ...

    @staticmethod
    def isScanHasTime(arg: LaserScanFormat, /) -> bool: ...

    @overload
    @staticmethod
    def backwardCompatibility(arg0: numpy.array, arg1: int, arg2: int, /) -> LaserScan: ...

    @overload
    @staticmethod
    def backwardCompatibility(arg0: numpy.array, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, /) -> LaserScan: ...

    @overload
    def clone(self) -> LaserScan: ...

    @overload
    def clone(self) -> LaserScan: ...

    def data(self) -> numpy.array: ...

    def format(self) -> LaserScanFormat: ...

    def formatName(self) -> str: ...

    def channels(self) -> int: ...

    def maxPoints(self) -> int: ...

    def rangeMin(self) -> float: ...

    def rangeMax(self) -> float: ...

    def angleMin(self) -> float: ...

    def angleMax(self) -> float: ...

    def angleIncrement(self) -> float: ...

    def setLocalTransform(self, arg: Transform, /) -> None: ...

    def localTransform(self) -> Transform: ...

    def empty(self) -> bool: ...

    def isEmpty(self) -> bool: ...

    def size(self) -> int: ...

    def dataType(self) -> int: ...

    def is2d(self) -> bool: ...

    def hasNormals(self) -> bool: ...

    def hasRGB(self) -> bool: ...

    def hasIntensity(self) -> bool: ...

    def hasTime(self) -> bool: ...

    def isCompressed(self) -> bool: ...

    def isOrganized(self) -> bool: ...

    def densify(self) -> LaserScan: ...

    def getIntensityOffset(self) -> int: ...

    def getRGBOffset(self) -> int: ...

    def getNormalsOffset(self) -> int: ...

    def getTimeOffset(self) -> int: ...

    def field(self, arg0: int, arg1: int, /) -> float: ...

    def clear(self) -> None: ...

class LaserScanFormat(enum.Enum):
    kUnknown = 0

    kXY = 1

    kXYI = 2

    kXYNormal = 3

    kXYINormal = 4

    kXYZ = 5

    kXYZI = 6

    kXYZRGB = 7

    kXYZNormal = 8

    kXYZINormal = 9

    kXYZRGBNormal = 10

    kXYZIT = 11

class Odometry:
    @overload
    @staticmethod
    def create() -> None: ...

    @overload
    @staticmethod
    def create(arg: OdometryType, /) -> None: ...

    @overload
    def process(self, arg0: SensorData, arg1: OdometryInfo, /) -> Transform: ...

    @overload
    def process(self, arg0: SensorData, arg1: Transform, arg2: OdometryInfo, /) -> Transform: ...

    def reset(self, arg: Transform, /) -> None: ...

    def getType(self) -> OdometryType: ...

    def canProcessRawImages(self) -> bool: ...

    def canProcessAsyncIMU(self) -> bool: ...

    def getPose(self) -> Transform: ...

    def isInfoDataFilled(self) -> bool: ...

    def getVelocityGuess(self) -> Transform: ...

    def previousStamp(self) -> float: ...

    def framesProcessed(self) -> int: ...

    def imagesAlreadyRectified(self) -> bool: ...

class OdometryInfo:
    def __init__(self) -> None: ...

    def statistics(self, arg: Transform, /) -> dict[str, float]: ...

    @property
    def lost(self) -> bool: ...

    @lost.setter
    def lost(self, arg: bool, /) -> None: ...

    @property
    def reg(self) -> "rtabmap::RegistrationInfo": ...

    @reg.setter
    def reg(self, arg: "rtabmap::RegistrationInfo", /) -> None: ...

    @property
    def features(self) -> int: ...

    @features.setter
    def features(self, arg: int, /) -> None: ...

    @property
    def localMapSize(self) -> int: ...

    @localMapSize.setter
    def localMapSize(self, arg: int, /) -> None: ...

    @property
    def localScanMapSize(self) -> int: ...

    @localScanMapSize.setter
    def localScanMapSize(self, arg: int, /) -> None: ...

    @property
    def localKeyFrames(self) -> int: ...

    @localKeyFrames.setter
    def localKeyFrames(self, arg: int, /) -> None: ...

    @property
    def localBundleOutliers(self) -> int: ...

    @localBundleOutliers.setter
    def localBundleOutliers(self, arg: int, /) -> None: ...

    @property
    def localBundleConstraints(self) -> int: ...

    @localBundleConstraints.setter
    def localBundleConstraints(self, arg: int, /) -> None: ...

    @property
    def localBundleTime(self) -> float: ...

    @localBundleTime.setter
    def localBundleTime(self, arg: float, /) -> None: ...

    @property
    def localBundlePoses(self) -> dict[int, Transform]: ...

    @localBundlePoses.setter
    def localBundlePoses(self, arg: Mapping[int, Transform], /) -> None: ...

    @property
    def localBundleModels(self) -> dict[int, list[CameraModel]]: ...

    @localBundleModels.setter
    def localBundleModels(self, arg: Mapping[int, Sequence[CameraModel]], /) -> None: ...

    @property
    def localBundleAvgInlierDistance(self) -> float: ...

    @localBundleAvgInlierDistance.setter
    def localBundleAvgInlierDistance(self, arg: float, /) -> None: ...

    @property
    def localBundleMaxKeyFramesForInlier(self) -> int: ...

    @localBundleMaxKeyFramesForInlier.setter
    def localBundleMaxKeyFramesForInlier(self, arg: int, /) -> None: ...

    @property
    def localBundleOutliersPerCam(self) -> list[int]: ...

    @localBundleOutliersPerCam.setter
    def localBundleOutliersPerCam(self, arg: Sequence[int], /) -> None: ...

    @property
    def keyFrameAdded(self) -> bool: ...

    @keyFrameAdded.setter
    def keyFrameAdded(self, arg: bool, /) -> None: ...

    @property
    def timeDeskewing(self) -> float: ...

    @timeDeskewing.setter
    def timeDeskewing(self, arg: float, /) -> None: ...

    @property
    def timeEstimation(self) -> float: ...

    @timeEstimation.setter
    def timeEstimation(self, arg: float, /) -> None: ...

    @property
    def timeParticleFiltering(self) -> float: ...

    @timeParticleFiltering.setter
    def timeParticleFiltering(self, arg: float, /) -> None: ...

    @property
    def stamp(self) -> float: ...

    @stamp.setter
    def stamp(self, arg: float, /) -> None: ...

    @property
    def interval(self) -> float: ...

    @interval.setter
    def interval(self, arg: float, /) -> None: ...

    @property
    def transform(self) -> Transform: ...

    @transform.setter
    def transform(self, arg: Transform, /) -> None: ...

    @property
    def transformFiltered(self) -> Transform: ...

    @transformFiltered.setter
    def transformFiltered(self, arg: Transform, /) -> None: ...

    @property
    def transformGroundTruth(self) -> Transform: ...

    @transformGroundTruth.setter
    def transformGroundTruth(self, arg: Transform, /) -> None: ...

    @property
    def guessVelocity(self) -> Transform: ...

    @guessVelocity.setter
    def guessVelocity(self, arg: Transform, /) -> None: ...

    @property
    def guess(self) -> Transform: ...

    @guess.setter
    def guess(self, arg: Transform, /) -> None: ...

    @property
    def distanceTravelled(self) -> float: ...

    @distanceTravelled.setter
    def distanceTravelled(self, arg: float, /) -> None: ...

    @property
    def memoryUsage(self) -> int: ...

    @memoryUsage.setter
    def memoryUsage(self, arg: int, /) -> None: ...

    @property
    def gravityRollError(self) -> float: ...

    @gravityRollError.setter
    def gravityRollError(self, arg: float, /) -> None: ...

    @property
    def gravityPitchError(self) -> float: ...

    @gravityPitchError.setter
    def gravityPitchError(self, arg: float, /) -> None: ...

    @property
    def type(self) -> int: ...

    @type.setter
    def type(self, arg: int, /) -> None: ...

    @property
    def localMap(self) -> dict[int, "cv::Point3_<float>"]: ...

    @localMap.setter
    def localMap(self, arg: Mapping[int, "cv::Point3_<float>"], /) -> None: ...

    @property
    def localScanMap(self) -> LaserScan: ...

    @localScanMap.setter
    def localScanMap(self, arg: LaserScan, /) -> None: ...

    @property
    def refCorners(self) -> list["cv::Point_<float>"]: ...

    @refCorners.setter
    def refCorners(self, arg: Sequence["cv::Point_<float>"], /) -> None: ...

    @property
    def newCorners(self) -> list["cv::Point_<float>"]: ...

    @newCorners.setter
    def newCorners(self, arg: Sequence["cv::Point_<float>"], /) -> None: ...

    @property
    def cornerInliers(self) -> list[int]: ...

    @cornerInliers.setter
    def cornerInliers(self, arg: Sequence[int], /) -> None: ...

class OdometryType(enum.Enum):
    kTypeUndef = -1

    kTypeF2M = 0

    kTypeF2F = 1

    kTypeFovis = 2

    kTypeViso2 = 3

    kTypeDVO = 4

    kTypeORBSLAM = 5

    kTypeOkvis = 6

    kTypeLOAM = 7

    kTypeMSCKF = 8

    kTypeVINSFusion = 9

    kTypeOpenVINS = 10

    kTypeFLOAM = 11

    kTypeOpen3D = 12

class SensorData:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg0: numpy.array, arg1: int, arg2: float, /) -> None: ...

    @overload
    def __init__(self, arg0: numpy.array, arg1: CameraModel, arg2: int, arg3: float, /) -> None: ...

    @overload
    def __init__(self, arg0: numpy.array, arg1: numpy.array, arg2: CameraModel, arg3: int, arg4: float, /) -> None: ...

    @overload
    def __init__(self, arg0: LaserScan, arg1: numpy.array, arg2: numpy.array, arg3: CameraModel, arg4: int, arg5: float, /) -> None: ...

    @overload
    def __init__(self, arg0: LaserScan, arg1: numpy.array, arg2: numpy.array, arg3: numpy.array, arg4: CameraModel, arg5: int, arg6: float, /) -> None: ...

    @overload
    def __init__(self, arg0: numpy.array, arg1: numpy.array, arg2: Sequence[CameraModel], arg3: int, arg4: float, /) -> None: ...

    @overload
    def __init__(self, arg0: numpy.array, arg1: numpy.array, arg2: numpy.array, arg3: Sequence[CameraModel], arg4: int, arg5: float, /) -> None: ...

    @overload
    def __init__(self, arg0: LaserScan, arg1: numpy.array, arg2: numpy.array, arg3: Sequence[CameraModel], arg4: int, arg5: float, /) -> None: ...

    @overload
    def __init__(self, arg0: LaserScan, arg1: numpy.array, arg2: numpy.array, arg3: numpy.array, arg4: Sequence[CameraModel], arg5: int, arg6: float, /) -> None: ...

    @overload
    def __init__(self, arg0: numpy.array, arg1: numpy.array, arg2: "rtabmap::StereoCameraModel", arg3: int, arg4: float, /) -> None: ...

    @overload
    def __init__(self, arg0: LaserScan, arg1: numpy.array, arg2: numpy.array, arg3: "rtabmap::StereoCameraModel", arg4: int, arg5: float, /) -> None: ...

    @overload
    def __init__(self, arg0: numpy.array, arg1: numpy.array, arg2: Sequence["rtabmap::StereoCameraModel"], arg3: int, arg4: float, /) -> None: ...

    @overload
    def __init__(self, arg0: LaserScan, arg1: numpy.array, arg2: numpy.array, arg3: Sequence["rtabmap::StereoCameraModel"], arg4: int, arg5: float, /) -> None: ...

    @overload
    def __init__(self, arg0: "rtabmap::IMU", arg1: int, arg2: float, /) -> None: ...

    def isValid(self) -> bool: ...

    def id(self) -> int: ...

    def setId(self, arg: int, /) -> None: ...

    def stamp(self) -> float: ...

    def setStamp(self, arg: float, /) -> None: ...

    def imageCompressed(self) -> numpy.array: ...

    def depthOrRightCompressed(self) -> numpy.array: ...

    def depthConfidenceCompressed(self) -> numpy.array: ...

    def laserScanCompressed(self) -> LaserScan: ...

    def imageRaw(self) -> numpy.array: ...

    def depthOrRightRaw(self) -> numpy.array: ...

    def depthConfidenceRaw(self) -> numpy.array: ...

    def laserScanRaw(self) -> LaserScan: ...

    @overload
    def setRGBDImage(self, arg0: numpy.array, arg1: numpy.array, arg2: CameraModel, arg3: bool, /) -> None: ...

    @overload
    def setRGBDImage(self, arg0: numpy.array, arg1: numpy.array, arg2: CameraModel, arg3: bool, /) -> None: ...

    @overload
    def setRGBDImage(self, arg0: numpy.array, arg1: numpy.array, arg2: numpy.array, arg3: CameraModel, arg4: bool, /) -> None: ...

    @overload
    def setRGBDImage(self, arg0: numpy.array, arg1: numpy.array, arg2: Sequence[CameraModel], arg3: bool, /) -> None: ...

    @overload
    def setStereoImage(self, arg0: numpy.array, arg1: numpy.array, arg2: "rtabmap::StereoCameraModel", arg3: bool, /) -> None: ...

    @overload
    def setStereoImage(self, arg0: numpy.array, arg1: numpy.array, arg2: Sequence["rtabmap::StereoCameraModel"], arg3: bool, /) -> None: ...

    def setLaserScan(self, arg0: LaserScan, arg1: bool, /) -> None: ...

    def setCameraModel(self, arg: CameraModel, /) -> None: ...

    def setCameraModels(self, arg: Sequence[CameraModel], /) -> None: ...

    def setStereoCameraModel(self, arg: "rtabmap::StereoCameraModel", /) -> None: ...

    def setStereoCameraModels(self, arg: Sequence["rtabmap::StereoCameraModel"], /) -> None: ...

    def depthRaw(self) -> numpy.array: ...

    def rightRaw(self) -> numpy.array: ...

    def uncompressData(self) -> None: ...

    def cameraModels(self) -> list[CameraModel]: ...

    def stereoCameraModels(self) -> list["rtabmap::StereoCameraModel"]: ...

    def setUserData(self, arg0: numpy.array, arg1: bool, /) -> None: ...

    def userDataRaw(self) -> numpy.array: ...

    def userDataCompressed(self) -> numpy.array: ...

    def setOccupancyGrid(self, arg0: numpy.array, arg1: numpy.array, arg2: numpy.array, arg3: float, arg4: tuple, /) -> None: ...

    def clearOccupancyGridRaw(self) -> None: ...

    def gridGroundCellsRaw(self) -> numpy.array: ...

    def gridGroundCellsCompressed(self) -> numpy.array: ...

    def gridObstacleCellsRaw(self) -> numpy.array: ...

    def gridObstacleCellsCompressed(self) -> numpy.array: ...

    def gridEmptyCellsRaw(self) -> numpy.array: ...

    def gridEmptyCellsCompressed(self) -> numpy.array: ...

    def gridCellSize(self) -> float: ...

    def gridViewPoint(self) -> tuple: ...

    def setFeatures(self, arg0: Sequence["cv::KeyPoint"], arg1: Sequence[tuple], arg2: numpy.array, /) -> None: ...

    def keypoints(self) -> list["cv::KeyPoint"]: ...

    def keypoints3D(self) -> list[tuple]: ...

    def descriptors(self) -> numpy.array: ...

    def addGlobalDescriptor(self, arg: "rtabmap::GlobalDescriptor", /) -> None: ...

    def setGlobalDescriptors(self, arg: Sequence["rtabmap::GlobalDescriptor"], /) -> None: ...

    def clearGlobalDescriptors(self) -> None: ...

    def globalDescriptors(self) -> list["rtabmap::GlobalDescriptor"]: ...

    def setGroundTruth(self, arg: Transform, /) -> None: ...

    def groundTruth(self) -> Transform: ...

    def setGlobalPose(self, arg0: Transform, arg1: numpy.array, /) -> None: ...

    def globalPose(self) -> Transform: ...

    def globalPoseCovariance(self) -> numpy.array: ...

    def setGPS(self, arg: "rtabmap::GPS", /) -> None: ...

    def gps(self) -> "rtabmap::GPS": ...

    def setIMU(self, arg: "rtabmap::IMU", /) -> None: ...

    def imu(self) -> "rtabmap::IMU": ...

    def setEnvSensors(self, arg: Mapping["rtabmap::EnvSensor::Type", "rtabmap::EnvSensor"], /) -> None: ...

    def addEnvSensor(self, arg: "rtabmap::EnvSensor", /) -> None: ...

    @overload
    def envSensors(self) -> dict["rtabmap::EnvSensor::Type", "rtabmap::EnvSensor"]: ...

    @overload
    def envSensors(self) -> dict["rtabmap::EnvSensor::Type", "rtabmap::EnvSensor"]: ...

    def setLandmarks(self, arg: Mapping[int, "rtabmap::Landmark"], /) -> None: ...

    def landmarks(self) -> dict[int, "rtabmap::Landmark"]: ...

    def getMemoryUsed(self) -> int: ...

    def clearCompressedData(self, arg0: bool, arg1: bool, arg2: bool, /) -> None: ...

    def clearRawData(self, arg0: bool, arg1: bool, arg2: bool, /) -> None: ...

    def isPointVisibleFromCameras(self, arg: tuple, /) -> bool: ...

class Transform:
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, /) -> None: ...

    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, /) -> None: ...

    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, /) -> None: ...

    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, /) -> None: ...

    def clone(self) -> Transform: ...

    def r11(self) -> float: ...

    def r12(self) -> float: ...

    def r13(self) -> float: ...

    def r21(self) -> float: ...

    def r22(self) -> float: ...

    def r23(self) -> float: ...

    def r31(self) -> float: ...

    def r32(self) -> float: ...

    def r33(self) -> float: ...

    def o14(self) -> float: ...

    def o24(self) -> float: ...

    def o34(self) -> float: ...

    def isNull(self) -> bool: ...

    def isIdentity(self) -> bool: ...

    def size(self) -> int: ...

    def theta(self) -> float: ...

    def isInvertible(self) -> bool: ...

    def inverse(self) -> Transform: ...

    def rotation(self) -> Transform: ...

    def translation(self) -> Transform: ...

    def to3DoF(self) -> Transform: ...

    def to4DoF(self) -> Transform: ...

    def is3DoF(self) -> bool: ...

    def is4DoF(self) -> bool: ...

    def rotationMatrix(self) -> numpy.array: ...

    def translationMatrix(self) -> numpy.array: ...

    def getTranslationAndEulerAngles(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, /) -> None: ...

    def getEulerAngles(self, arg0: float, arg1: float, arg2: float, /) -> None: ...

    def getTranslation(self, arg0: float, arg1: float, arg2: float, /) -> None: ...

    def getAngle(self, arg: Transform, /) -> float: ...

    def getNorm(self) -> float: ...

    def getNormSquared(self) -> float: ...

    def getDistance(self, arg: Transform, /) -> float: ...

    def getDistanceSquared(self, arg: Transform, /) -> float: ...

    def interpolate(self, arg0: float, arg1: Transform, /) -> Transform: ...

    def normalizeRotation(self) -> None: ...

    def prettyPrint(self) -> str: ...

    def toEigen4f(self) -> "Eigen::Matrix<float, 4, 4, 0, 4, 4>": ...

    def toEigen4d(self) -> "Eigen::Matrix<double, 4, 4, 0, 4, 4>": ...

    def toEigen3f(self) -> "Eigen::Transform<float, 3, 2, 0>": ...

    def toEigen3d(self) -> "Eigen::Transform<double, 3, 2, 0>": ...

    def getQuaternionf(self) -> "Eigen::Quaternion<float, 0>": ...

    def getQuaterniond(self) -> "Eigen::Quaternion<double, 0>": ...

    @staticmethod
    def getIdentity() -> Transform: ...

    @staticmethod
    def fromEigen4f(arg: "Eigen::Matrix<float, 4, 4, 0, 4, 4>", /) -> Transform: ...

    @staticmethod
    def fromEigen4d(arg: "Eigen::Matrix<double, 4, 4, 0, 4, 4>", /) -> Transform: ...

    @staticmethod
    def opengl_T_rtabmap() -> Transform: ...

    @staticmethod
    def rtabmap_T_opengl() -> Transform: ...

    @staticmethod
    def fromString(arg: str, /) -> Transform: ...

    @staticmethod
    def canParseString(arg: str, /) -> bool: ...

    @staticmethod
    def getTransform(arg0: Mapping[float, Transform], arg1: float, /) -> Transform: ...

def add(a: int, b: int) -> int: ...
