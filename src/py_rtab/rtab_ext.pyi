from collections.abc import Mapping, Sequence, Set
import enum
from typing import Annotated, overload

import numpy
from numpy.typing import ArrayLike


class Camera(SensorCapture):
    @overload
    def takeImage(self) -> SensorData: ...

    @overload
    def takeImage(self, info: SensorCaptureInfo) -> SensorData: ...

    def getImageRate(self) -> float: ...

    def setImageRate(self, imageRate: float) -> None: ...

    def setInterIMUPublishing(self, enabled: bool, filter: IMUFilter) -> None: ...

    def isInterIMUPublishing(self) -> bool: ...

    def initFromFile(self, calibrationPath: str) -> bool: ...

    def isCalibrated(self) -> bool: ...

class CameraImages(Camera):
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, path: str, imageRate: float = 0) -> None: ...

    def init(self, calibrationFolder: str = '.', cameraName: str = '') -> bool: ...

    def isCalibrated(self) -> bool: ...

    def getSerial(self) -> str: ...

    def odomProvided(self) -> bool: ...

    def getPath(self) -> str: ...

    def imagesCount(self) -> int: ...

    def filenames(self) -> list[str]: ...

    def isImagesRectified(self) -> bool: ...

    def getBayerMode(self) -> int: ...

    def cameraModel(self) -> CameraModel: ...

    def setPath(self, dir: str) -> None: ...

    def setStartIndex(self, index: int) -> None: ...

    def setMaxFrames(self, value: int) -> None: ...

    def setDirRefreshed(self, enabled: bool) -> None: ...

    def setImagesRectified(self, enabled: bool) -> None: ...

    def setBayerMode(self, mode: int) -> None: ...

    def setTimestamps(self, fileNamesAreStamps: bool, filePath: str = '', syncImageRateWithStamps: bool = True) -> None: ...

    def setConfigForEachFrame(self, value: bool) -> None: ...

    def setScanPath(self, dir: str, maxScanPts: int, localTransform: Transform) -> None: ...

    def setDepthFromScan(self, enabled: bool, fillHoles: int = 1, fillHolesFromBorder: bool = False) -> None: ...

    def setOdometryPath(self, filePath: str, format: int = 0) -> None: ...

    def setGroundTruthPath(self, filePath: str, format: int = 0) -> None: ...

    def setMaxPoseTimeDiff(self, diff: float) -> None: ...

    def getMaxPoseTimeDiff(self) -> float: ...

    def setDepth(self, isDepth: bool, depthScaleFactor: float = 1.0) -> None: ...

class CameraModel:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, name: str, imageSize: tuple, K: numpy.array, D: numpy.array, R: numpy.array, P: numpy.array, localTransform: Transform) -> None: ...

    @overload
    def __init__(self, fx: float, fy: float, cx: float, cy: float, localTransform: Transform, Tx: float, imageSize: tuple) -> None: ...

    @overload
    def __init__(self, name: str, fx: float, fy: float, cx: float, cy: float, localTransform: Transform, Tx: float, imageSize: tuple) -> None: ...

    @staticmethod
    def opticalRotation() -> Transform: ...

    def initRectificationMap(self) -> bool: ...

    def isRectificationMapInitialized(self) -> bool: ...

    def isValidForProjection(self) -> bool: ...

    def isValidForReprojection(self) -> bool: ...

    def isValidForRectification(self) -> bool: ...

    def setName(self, name: str) -> None: ...

    def name(self) -> str: ...

    def fx(self) -> float: ...

    def fy(self) -> float: ...

    def cx(self) -> float: ...

    def cy(self) -> float: ...

    def Tx(self) -> float: ...

    def setLocalTransform(self, transform: Transform) -> None: ...

    def localTransform(self) -> Transform: ...

    def setImageSize(self, size: tuple) -> None: ...

    def imageSize(self) -> tuple: ...

    def imageWidth(self) -> int: ...

    def imageHeight(self) -> int: ...

    def fovX(self) -> float: ...

    def fovY(self) -> float: ...

    def horizontalFOV(self) -> float: ...

    def verticalFOV(self) -> float: ...

    def isFisheye(self) -> bool: ...

    @overload
    def load(self, filePath: str) -> bool: ...

    @overload
    def load(self, directory: str, cameraName: str) -> bool: ...

    def save(self, directory: str) -> bool: ...

    def serialize(self) -> list[int]: ...

    def deserialize(self, data: Sequence[int]) -> int: ...

    def scaled(self, scale: float) -> CameraModel: ...

    def roi(self, roi: tuple) -> CameraModel: ...

    def project(self, u: float, v: float, depth: float, x: float, y: float, z: float) -> None: ...

    def inFrame(self, u: int, v: int) -> bool: ...

class CameraRGBDImages(CameraImages):
    def __init__(self, pathRGBImages: str, pathDepthImages: str, depthScaleFactor: float = 1.0, imageRate: float = 0.0) -> None: ...

    def init(self, calibrationFolder: str, cameraName: str = 0) -> bool: ...

    def setStartIndex(self, index: int) -> None: ...

    def setMaxFrames(self, value: int) -> None: ...

class CameraRealSense2(Camera):
    def __init__(self, deviceId: str = '', imageRate: float = 0) -> None: ...

    def init(self, calibrationFolder: str = '.', cameraName: str = '') -> bool: ...

    def isCalibrated(self) -> bool: ...

    def getSerial(self) -> str: ...

    def odomProvided(self) -> bool: ...

    def getPose(self, stamp: float, maxWaitTime: float = 0.06) -> tuple[bool, Transform, numpy.array]: ...

    def setEmitterEnabled(self, enabled: bool) -> None: ...

    def setIRFormat(self, enabled: bool, useDepthInsteadOfRightImage: bool) -> None: ...

    def setResolution(self, width: int, height: int, fps: int = 30) -> None: ...

    def setDepthResolution(self, width: int, height: int, fps: int = 30) -> None: ...

    def setGlobalTimeSync(self, enabled: bool) -> None: ...

    def setDualMode(self, enabled: bool, extrinsics: Transform) -> None: ...

    def setJsonConfig(self, json: str) -> None: ...

    def setImagesRectified(self, enabled: bool) -> None: ...

    def setOdomProvided(self, enabled: bool, imageStreamsDisabled: bool = False, onlyLeftStream: bool = False) -> None: ...

class EnvSensor:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, type: EnvSensorType, value: float, stamp: float = 0) -> None: ...

    def type(self) -> EnvSensorType: ...

    def value(self) -> float: ...

    def stamp(self) -> float: ...

class EnvSensorType(enum.Enum):
    kUndefined = 0

    kWifiSignalStrength = 1

    kAmbientTemperature = 2

    kAmbientAirPressure = 3

    kAmbientLight = 4

    kAmbientRelativeHumidity = 5

    kCustomSensor1 = 100

    kCustomSensor2 = 101

    kCustomSensor3 = 102

    kCustomSensor4 = 103

    kCustomSensor5 = 104

    kCustomSensor6 = 105

    kCustomSensor7 = 106

    kCustomSensor8 = 107

    kCustomSensor9 = 108

class Feature2D:
    @staticmethod
    def create(type: Feature2DType) -> Feature2D: ...

    def getMaxFeatures(self) -> int: ...

    def getSSC(self) -> bool: ...

    def getMinDepth(self) -> float: ...

    def getMaxDepth(self) -> float: ...

    def getGridRows(self) -> int: ...

    def getGridCols(self) -> int: ...

    def generateKeypoints(self, image: numpy.array, mask: numpy.array) -> list["cv::KeyPoint"]: ...

    def generateDescriptors(self, image: numpy.array, keypoints: Sequence["cv::KeyPoint"]) -> numpy.array: ...

    def generateKeypoints3D(self, data: SensorData, keypoints: Sequence["cv::KeyPoint"]) -> list[tuple]: ...

    def parseParameters(self, parameters: Mapping[str, str]) -> None: ...

    def getParameters(self) -> dict[str, str]: ...

class Feature2DType(enum.Enum):
    kFeatureUndef = -1

    kFeatureSurf = 0

    kFeatureSift = 1

    kFeatureOrb = 2

    kFeatureFastFreak = 3

    kFeatureFastBrief = 4

    kFeatureGfttFreak = 5

    kFeatureGfttBrief = 6

    kFeatureBrisk = 7

    kFeatureGfttOrb = 8

    kFeatureKaze = 9

    kFeatureOrbOctree = 10

    kFeatureSuperPointTorch = 11

    kFeatureSurfFreak = 12

    kFeatureGfttDaisy = 13

    kFeatureSurfDaisy = 14

    kFeaturePyDetector = 15

class GPS:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, stamp: float, longitude: float, latitude: float, altitude: float, error: float, bearing: float) -> None: ...

    def stamp(self) -> float: ...

    def longitude(self) -> float: ...

    def latitude(self) -> float: ...

    def altitude(self) -> float: ...

    def error(self) -> float: ...

    def bearing(self) -> float: ...

    def toGeodeticCoords(self) -> GeodeticCoords: ...

class GeodeticCoords:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, latitude: float, longitude: float, altitude: float) -> None: ...

    def latitude(self) -> float: ...

    def longitude(self) -> float: ...

    def altitude(self) -> float: ...

    def setLatitude(self, value: float) -> None: ...

    def setLongitude(self, value: float) -> None: ...

    def setAltitude(self, value: float) -> None: ...

    def toGeocentric_WGS84(self) -> tuple: ...

    def toENU_WGS84(self, origin: GeodeticCoords) -> tuple: ...

    def fromGeocentric_WGS84(self, geocentric: tuple) -> None: ...

    def fromENU_WGS84(self, enu: tuple, origin: GeodeticCoords) -> None: ...

class GlobalDescriptor:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, type: int, data: numpy.array, info: numpy.array) -> None: ...

    def type(self) -> int: ...

    def info(self) -> numpy.array: ...

    def data(self) -> numpy.array: ...

class IMU:
    @overload
    def __init__(self, orientation: list, orientationCovariance: numpy.array, angularVelocity: list, angularVelocityCovariance: numpy.array, linearAcceleration: list, linearAccelerationCovariance: numpy.array) -> None: ...

    @overload
    def __init__(self, angularVelocity: list, angularVelocityCovariance: numpy.array, linearAcceleration: list, linearAccelerationCovariance: numpy.array) -> None: ...

    def orientation(self) -> list: ...

    def orientationCovariance(self) -> numpy.array: ...

    def angularVelocity(self) -> list: ...

    def angularVelocityCovariance(self) -> numpy.array: ...

    def linearAcceleration(self) -> list: ...

    def linearAccelerationCovariance(self) -> numpy.array: ...

    def localTransform(self) -> Transform: ...

    def convertToBaseFrame(self) -> None: ...

    def empty(self) -> bool: ...

class IMUFilter:
    def parseParameters(self, parameters: Mapping[str, str]) -> None: ...

    def update(self, gx: float, gy: float, gz: float, ax: float, ay: float, az: float, stamp: float) -> None: ...

    def type(self) -> IMUFilterType: ...

    def getOrientation(self) -> tuple[float, float, float, float]: ...

    def reset(self, qx: float, qy: float, qz: float, qw: float) -> None: ...

class IMUFilterType(enum.Enum):
    kMadgwick = 0

    kComplementaryFilter = 1

class Landmark:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, id: int, size: float, pose: Transform, covariance: numpy.array) -> None: ...

    def id(self) -> int: ...

    def size(self) -> float: ...

    def pose(self) -> Transform: ...

    def covariance(self) -> numpy.array: ...

class LaserScan:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, data: LaserScan, maxPoints: int, maxRange: float) -> None: ...

    @overload
    def __init__(self, data: numpy.array, maxPoints: int, maxRange: float, format: LaserScanFormat) -> None: ...

    @overload
    def __init__(self, data: LaserScan, minRange: float, maxRange: float, angleMin: float, angleMax: float, angleIncrement: float) -> None: ...

    @overload
    def __init__(self, data: numpy.array, format: LaserScanFormat, minRange: float, maxRange: float, angleMin: float, angleMax: float, angleIncrement: float) -> None: ...

    @staticmethod
    def isScan2d(format: LaserScanFormat) -> bool: ...

    @staticmethod
    def isScanHasNormals(format: LaserScanFormat) -> bool: ...

    @staticmethod
    def isScanHasRGB(format: LaserScanFormat) -> bool: ...

    @staticmethod
    def isScanHasIntensity(format: LaserScanFormat) -> bool: ...

    @staticmethod
    def isScanHasTime(format: LaserScanFormat) -> bool: ...

    @overload
    @staticmethod
    def backwardCompatibility(oldScanFormat: numpy.array, maxPoints: int = 0, maxRange: int = 0) -> LaserScan: ...

    @overload
    @staticmethod
    def backwardCompatibility(oldScanFormat: numpy.array, minRange: float, maxRange: float, angleMin: float, angleMax: float, angleInc: float) -> LaserScan: ...

    @overload
    def clone(self) -> LaserScan: ...

    @overload
    def clone(self) -> LaserScan: ...

    def data(self) -> numpy.array: ...

    def format(self) -> LaserScanFormat: ...

    def formatName(self) -> str: ...

    def channels(self) -> int: ...

    def maxPoints(self) -> int: ...

    def rangeMin(self) -> float: ...

    def rangeMax(self) -> float: ...

    def angleMin(self) -> float: ...

    def angleMax(self) -> float: ...

    def angleIncrement(self) -> float: ...

    def setLocalTransform(self, t: Transform) -> None: ...

    def localTransform(self) -> Transform: ...

    def empty(self) -> bool: ...

    def isEmpty(self) -> bool: ...

    def size(self) -> int: ...

    def dataType(self) -> int: ...

    def is2d(self) -> bool: ...

    def hasNormals(self) -> bool: ...

    def hasRGB(self) -> bool: ...

    def hasIntensity(self) -> bool: ...

    def hasTime(self) -> bool: ...

    def isCompressed(self) -> bool: ...

    def isOrganized(self) -> bool: ...

    def densify(self) -> LaserScan: ...

    def getIntensityOffset(self) -> int: ...

    def getRGBOffset(self) -> int: ...

    def getNormalsOffset(self) -> int: ...

    def getTimeOffset(self) -> int: ...

    def field(self, pointIndex: int, channelOffset: int) -> float: ...

    def clear(self) -> None: ...

class LaserScanFormat(enum.Enum):
    kUnknown = 0

    kXY = 1

    kXYI = 2

    kXYNormal = 3

    kXYINormal = 4

    kXYZ = 5

    kXYZI = 6

    kXYZRGB = 7

    kXYZNormal = 8

    kXYZINormal = 9

    kXYZRGBNormal = 10

    kXYZIT = 11

class Link:
    def __init__(self, from: int, to: int, type: LinkType, transform: Transform) -> None: ...

    def isValid(self) -> bool: ...

    def from(self) -> int: ...

    def to(self) -> int: ...

    def transform(self) -> Transform: ...

    def type(self) -> LinkType: ...

    def infMatrix(self) -> numpy.array: ...

    def rotVariance(self, minimum: bool = True) -> float: ...

    def transVariance(self, minimum: bool = True) -> float: ...

    def setFrom(self, from: int) -> None: ...

    def setTo(self, to: int) -> None: ...

    def setTransform(self, transform: Transform) -> None: ...

    def setType(self, type: LinkType) -> None: ...

    def setInfMatrix(self, infMatrix: numpy.array) -> None: ...

    def userDataRaw(self) -> numpy.array: ...

    def userDataCompressed(self) -> numpy.array: ...

    def uncompressUserData(self) -> None: ...

    def uncompressUserDataConst(self) -> numpy.array: ...

    def merge(self, link: Link, outputType: LinkType) -> Link: ...

    def inverse(self) -> Link: ...

class LinkType(enum.Enum):
    kNeighbor = 0

    kGlobalClosure = 1

    kLocalSpaceClosure = 2

    kLocalTimeClosure = 3

    kUserClosure = 4

    kVirtualClosure = 5

    kNeighborMerged = 6

    kPosePrior = 7

    kLandmark = 8

    kGravity = 9

    kEnd = 10

    kSelfRefLink = 97

    kAllWithLandmarks = 98

    kAllWithoutLandmarks = 99

    kUndef = 99

class Memory:
    def __init__(self) -> None: ...

    def parseParameters(self, parameters: Mapping[str, str]) -> None: ...

    def getParameters(self) -> dict[str, str]: ...

    @overload
    def update(self, data: SensorData, stats: Statistics) -> bool: ...

    @overload
    def update(self, data: SensorData, pose: Transform, covariance: numpy.array, velocity: Sequence[float], stats: Statistics) -> bool: ...

    def init(self, dbUrl: str, dbOverwritten: bool, parameters: Mapping[str, str], postInitClosingEvents: bool) -> bool: ...

    def close(self, databaseSaved: bool = True, postInitClosingEvents: bool = False, ouputDatabasePath: str = '') -> None: ...

    def computeLikelihood(self, signature: Signature, ids: Sequence[int]) -> dict[int, float]: ...

    def incrementMapId(self, reducedIds: Mapping[int, int]) -> int: ...

    def updateAge(self, signatureId: int) -> None: ...

    def forget(self, ignoredIds: Set[int]) -> list[int]: ...

    def reactivateSignatures(self, ids: Sequence[int], maxLoaded: int, timeDbAccess: float) -> set[int]: ...

    def cleanup(self) -> int: ...

    def saveStatistics(self, statistics: Statistics, saveWMState: bool) -> None: ...

    def savePreviewImage(self, image: numpy.array) -> None: ...

    def loadPreviewImage(self) -> numpy.array: ...

    def saveOptimizedPoses(self, optimizedPoses: Mapping[int, Transform], lastlocalizationPose: Transform) -> None: ...

    def loadOptimizedPoses(self, lastlocalizationPose: Transform) -> dict[int, Transform]: ...

    def save2DMap(self, map: numpy.array, xMin: float, yMin: float, cellSize: float) -> None: ...

    def load2DMap(self, xMin: float, yMin: float, cellSize: float) -> numpy.array: ...

    def saveOptimizedMesh(self, cloud: numpy.array, polygons: Sequence[Sequence[Sequence[int]]], texCoords: Sequence[Sequence[Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]]], textures: numpy.array) -> None: ...

    def loadOptimizedMesh(self, polygons: Sequence[Sequence[Sequence[int]]], texCoords: Sequence[Sequence[Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]]], textures: numpy.array) -> numpy.array: ...

    def emptyTrash(self) -> None: ...

    def joinTrashThread(self) -> None: ...

    def addLink(self, link: Link, addInDatabase: bool) -> bool: ...

    def updateLink(self, link: Link, updateInDatabase: bool) -> None: ...

    def removeAllVirtualLinks(self) -> None: ...

    def removeVirtualLinks(self, signatureId: int) -> None: ...

    def getNeighborsId(self, signatureId: int, maxGraphDepth: int, maxCheckedInDatabase: int = -1, incrementMarginOnLoop: bool = False, ignoreLoopIds: bool = False, ignoreIntermediateNodes: bool = False, ignoreLocalSpaceLoopIds: bool = False, nodesSet: Set[int] = ..., dbAccessTime: float = 0) -> dict[int, int]: ...

    def getNeighborsIdRadius(self, signatureId: int, radius: float, optimizedPoses: Mapping[int, Transform], maxGraphDepth: int) -> dict[int, float]: ...

    def deleteLocation(self, locationId: int, deletedWords: Sequence[int]) -> None: ...

    def saveLocationData(self, locationId: int) -> None: ...

    def removeLink(self, idA: int, idB: int) -> None: ...

    def removeRawData(self, id: int, image: bool = True, scan: bool = True, userData: bool = True) -> None: ...

    def getWorkingMem(self) -> dict[int, float]: ...

    def getStMem(self) -> set[int]: ...

    def getMaxStMemSize(self) -> int: ...

    def isBinDataKept(self) -> bool: ...

    def getSimilarityThreshold(self) -> float: ...

    def getWeights(self) -> dict[int, int]: ...

    def getLastSignatureId(self) -> int: ...

    def getLastWorkingSignature(self) -> Signature: ...

    def getNodesObservingLandmark(self, landmarkId: int, lookInDatabase: bool) -> dict[int, Link]: ...

    def getSignatureIdByLabel(self, label: str, lookInDatabase: bool = True) -> int: ...

    def labelSignature(self, id: int, label: str) -> bool: ...

    def getAllLabels(self) -> dict[int, str]: ...

    def getLandmarksIndex(self) -> dict[int, set[int]]: ...

    def allNodesInWM(self) -> bool: ...

    def setUserData(self, id: int, data: numpy.array) -> bool: ...

    def getDatabaseMemoryUsed(self) -> int: ...

    def getDatabaseVersion(self) -> str: ...

    def getDatabaseUrl(self) -> str: ...

    def getDbSavingTime(self) -> float: ...

    def getMapId(self, id: int, lookInDatabase: bool = False) -> int: ...

    def getOdomPose(self, signatureId: int, lookInDatabase: bool = False) -> Transform: ...

    def getGroundTruthPose(self, signatureId: int, lookInDatabase: bool = False) -> Transform: ...

    def getGroundTruths(self) -> dict[int, Transform]: ...

    def getGPS(self, id: int, gps: GPS, offsetENU: Transform, lookInDatabase: bool, maxGraphDepth: int = 0) -> None: ...

    def getNodeInfo(self, signatureId: int, odomPose: Transform, mapId: int, weight: int, label: str, stamp: float, groundTruth: Transform, velocity: Sequence[float], gps: GPS, sensors: Mapping[EnvSensorType, EnvSensor], lookInDatabase: bool = False) -> bool: ...

    def getImageCompressed(self, signatureId: int) -> numpy.array: ...

    def getNodeData(self, locationId: int, images: bool, scan: bool, userData: bool, occupancyGrid: bool) -> SensorData: ...

    def getNodeCalibration(self, nodeId: int, models: Sequence[CameraModel], stereoModels: Sequence[StereoCameraModel]) -> None: ...

    def getAllSignatureIds(self, ignoreChildren: bool = True) -> set[int]: ...

    def memoryChanged(self) -> bool: ...

    def isIncremental(self) -> bool: ...

    def isLocalizationDataSaved(self) -> bool: ...

    def getSignature(self, id: int) -> Signature: ...

    def isInSTM(self, signatureId: int) -> bool: ...

    def isInWM(self, signatureId: int) -> bool: ...

    def isInLTM(self, signatureId: int) -> bool: ...

    def isIDsGenerated(self) -> bool: ...

    def getLastGlobalLoopClosureId(self) -> int: ...

    def getFeature2D(self) -> Feature2D: ...

    def isGraphReduced(self) -> bool: ...

    def getOdomMaxInf(self) -> list[float]: ...

    def isOdomGravityUsed(self) -> bool: ...

    def dumpMemoryTree(self, fileNameTree: str) -> None: ...

    def dumpMemory(self, directory: str) -> None: ...

    def dumpSignatures(self, fileNameSign: str, words3D: bool) -> None: ...

    def dumpDictionary(self, fileNameRef: str, fileNameDesc: str) -> None: ...

    def getMemoryUsed(self) -> int: ...

    def generateGraph(self, fileName: str, ids: Set[int] = ...) -> None: ...

    def cleanupLocalGrids(self, poses: Mapping[int, Transform], map: numpy.array, xMin: float, yMin: float, cellSize: float, cropRadius: int = 1, filterScans: bool = False) -> int: ...

    def getVWDictionary(self) -> VWDictionary: ...

    @overload
    def computeTransform(self, fromS: Signature, toS: Signature, guess: Transform, info: RegistrationInfo, useKnownCorrespondencesIfPossible: bool) -> Transform: ...

    @overload
    def computeTransform(self, fromId: int, toId: int, guess: Transform, info: RegistrationInfo, useKnownCorrespondencesIfPossible: bool) -> Transform: ...

    def computeIcpTransform(self, fromS: Signature, toS: Signature, guess: Transform, info: RegistrationInfo) -> Transform: ...

    def computeIcpTransformMulti(self, newId: int, oldId: int, poses: Mapping[int, Transform], info: RegistrationInfo) -> Transform: ...

class NNStrategy(enum.Enum):
    kNNFlannNaive = 0

    kNNFlannKdTree = 1

    kNNFlannLSH = 2

    kNNBruteForce = 3

    kNNBruteForceGPU = 4

    kNNUndef = 5

class Odometry:
    @overload
    @staticmethod
    def create() -> Odometry: ...

    @overload
    @staticmethod
    def create(type: OdometryType) -> Odometry: ...

    @overload
    def process(self, data: SensorData, info: OdometryInfo) -> Transform: ...

    @overload
    def process(self, data: SensorData, guess: Transform, info: OdometryInfo) -> Transform: ...

    def reset(self, initialPose: Transform) -> None: ...

    def getType(self) -> OdometryType: ...

    def canProcessRawImages(self) -> bool: ...

    def canProcessAsyncIMU(self) -> bool: ...

    def getPose(self) -> Transform: ...

    def isInfoDataFilled(self) -> bool: ...

    def getVelocityGuess(self) -> Transform: ...

    def previousStamp(self) -> float: ...

    def framesProcessed(self) -> int: ...

    def imagesAlreadyRectified(self) -> bool: ...

class OdometryInfo:
    def __init__(self) -> None: ...

    def statistics(self, pose: Transform) -> dict[str, float]: ...

    @property
    def lost(self) -> bool: ...

    @lost.setter
    def lost(self, arg: bool, /) -> None: ...

    @property
    def reg(self) -> RegistrationInfo: ...

    @reg.setter
    def reg(self, arg: RegistrationInfo, /) -> None: ...

    @property
    def features(self) -> int: ...

    @features.setter
    def features(self, arg: int, /) -> None: ...

    @property
    def localMapSize(self) -> int: ...

    @localMapSize.setter
    def localMapSize(self, arg: int, /) -> None: ...

    @property
    def localScanMapSize(self) -> int: ...

    @localScanMapSize.setter
    def localScanMapSize(self, arg: int, /) -> None: ...

    @property
    def localKeyFrames(self) -> int: ...

    @localKeyFrames.setter
    def localKeyFrames(self, arg: int, /) -> None: ...

    @property
    def localBundleOutliers(self) -> int: ...

    @localBundleOutliers.setter
    def localBundleOutliers(self, arg: int, /) -> None: ...

    @property
    def localBundleConstraints(self) -> int: ...

    @localBundleConstraints.setter
    def localBundleConstraints(self, arg: int, /) -> None: ...

    @property
    def localBundleTime(self) -> float: ...

    @localBundleTime.setter
    def localBundleTime(self, arg: float, /) -> None: ...

    @property
    def localBundlePoses(self) -> dict[int, Transform]: ...

    @localBundlePoses.setter
    def localBundlePoses(self, arg: Mapping[int, Transform], /) -> None: ...

    @property
    def localBundleModels(self) -> dict[int, list[CameraModel]]: ...

    @localBundleModels.setter
    def localBundleModels(self, arg: Mapping[int, Sequence[CameraModel]], /) -> None: ...

    @property
    def localBundleAvgInlierDistance(self) -> float: ...

    @localBundleAvgInlierDistance.setter
    def localBundleAvgInlierDistance(self, arg: float, /) -> None: ...

    @property
    def localBundleMaxKeyFramesForInlier(self) -> int: ...

    @localBundleMaxKeyFramesForInlier.setter
    def localBundleMaxKeyFramesForInlier(self, arg: int, /) -> None: ...

    @property
    def localBundleOutliersPerCam(self) -> list[int]: ...

    @localBundleOutliersPerCam.setter
    def localBundleOutliersPerCam(self, arg: Sequence[int], /) -> None: ...

    @property
    def keyFrameAdded(self) -> bool: ...

    @keyFrameAdded.setter
    def keyFrameAdded(self, arg: bool, /) -> None: ...

    @property
    def timeDeskewing(self) -> float: ...

    @timeDeskewing.setter
    def timeDeskewing(self, arg: float, /) -> None: ...

    @property
    def timeEstimation(self) -> float: ...

    @timeEstimation.setter
    def timeEstimation(self, arg: float, /) -> None: ...

    @property
    def timeParticleFiltering(self) -> float: ...

    @timeParticleFiltering.setter
    def timeParticleFiltering(self, arg: float, /) -> None: ...

    @property
    def stamp(self) -> float: ...

    @stamp.setter
    def stamp(self, arg: float, /) -> None: ...

    @property
    def interval(self) -> float: ...

    @interval.setter
    def interval(self, arg: float, /) -> None: ...

    @property
    def transform(self) -> Transform: ...

    @transform.setter
    def transform(self, arg: Transform, /) -> None: ...

    @property
    def transformFiltered(self) -> Transform: ...

    @transformFiltered.setter
    def transformFiltered(self, arg: Transform, /) -> None: ...

    @property
    def transformGroundTruth(self) -> Transform: ...

    @transformGroundTruth.setter
    def transformGroundTruth(self, arg: Transform, /) -> None: ...

    @property
    def guessVelocity(self) -> Transform: ...

    @guessVelocity.setter
    def guessVelocity(self, arg: Transform, /) -> None: ...

    @property
    def guess(self) -> Transform: ...

    @guess.setter
    def guess(self, arg: Transform, /) -> None: ...

    @property
    def distanceTravelled(self) -> float: ...

    @distanceTravelled.setter
    def distanceTravelled(self, arg: float, /) -> None: ...

    @property
    def memoryUsage(self) -> int: ...

    @memoryUsage.setter
    def memoryUsage(self, arg: int, /) -> None: ...

    @property
    def gravityRollError(self) -> float: ...

    @gravityRollError.setter
    def gravityRollError(self, arg: float, /) -> None: ...

    @property
    def gravityPitchError(self) -> float: ...

    @gravityPitchError.setter
    def gravityPitchError(self, arg: float, /) -> None: ...

    @property
    def type(self) -> int: ...

    @type.setter
    def type(self, arg: int, /) -> None: ...

    @property
    def localMap(self) -> dict[int, tuple]: ...

    @localMap.setter
    def localMap(self, arg: Mapping[int, tuple], /) -> None: ...

    @property
    def localScanMap(self) -> LaserScan: ...

    @localScanMap.setter
    def localScanMap(self, arg: LaserScan, /) -> None: ...

    @property
    def refCorners(self) -> list[tuple]: ...

    @refCorners.setter
    def refCorners(self, arg: Sequence[tuple], /) -> None: ...

    @property
    def newCorners(self) -> list[tuple]: ...

    @newCorners.setter
    def newCorners(self, arg: Sequence[tuple], /) -> None: ...

    @property
    def cornerInliers(self) -> list[int]: ...

    @cornerInliers.setter
    def cornerInliers(self, arg: Sequence[int], /) -> None: ...

class OdometryType(enum.Enum):
    kTypeUndef = -1

    kTypeF2M = 0

    kTypeF2F = 1

    kTypeFovis = 2

    kTypeViso2 = 3

    kTypeDVO = 4

    kTypeORBSLAM = 5

    kTypeOkvis = 6

    kTypeLOAM = 7

    kTypeMSCKF = 8

    kTypeVINSFusion = 9

    kTypeOpenVINS = 10

    kTypeFLOAM = 11

    kTypeOpen3D = 12

class ProgressState:
    def __init__(self) -> None: ...

    def setCanceled(self, canceled: bool) -> None: ...

    def isCanceled(self) -> bool: ...

class RegistrationInfo:
    def __init__(self) -> None: ...

    def copyWithoutData(self) -> RegistrationInfo: ...

    @property
    def covariance(self) -> numpy.array: ...

    @covariance.setter
    def covariance(self, arg: numpy.array, /) -> None: ...

    @property
    def rejectedMsg(self) -> str: ...

    @rejectedMsg.setter
    def rejectedMsg(self, arg: str, /) -> None: ...

    @property
    def totalTime(self) -> float: ...

    @totalTime.setter
    def totalTime(self, arg: float, /) -> None: ...

    @property
    def inliers(self) -> int: ...

    @inliers.setter
    def inliers(self, arg: int, /) -> None: ...

    @property
    def inliersRatio(self) -> float: ...

    @inliersRatio.setter
    def inliersRatio(self, arg: float, /) -> None: ...

    @property
    def inliersMeanDistance(self) -> float: ...

    @inliersMeanDistance.setter
    def inliersMeanDistance(self, arg: float, /) -> None: ...

    @property
    def inliersDistribution(self) -> float: ...

    @inliersDistribution.setter
    def inliersDistribution(self, arg: float, /) -> None: ...

    @property
    def inliersIDs(self) -> list[int]: ...

    @inliersIDs.setter
    def inliersIDs(self, arg: Sequence[int], /) -> None: ...

    @property
    def matches(self) -> int: ...

    @matches.setter
    def matches(self, arg: int, /) -> None: ...

    @property
    def matchesIDs(self) -> list[int]: ...

    @matchesIDs.setter
    def matchesIDs(self, arg: Sequence[int], /) -> None: ...

    @property
    def projectedIDs(self) -> list[int]: ...

    @projectedIDs.setter
    def projectedIDs(self, arg: Sequence[int], /) -> None: ...

    @property
    def inliersPerCam(self) -> list[int]: ...

    @inliersPerCam.setter
    def inliersPerCam(self, arg: Sequence[int], /) -> None: ...

    @property
    def matchesPerCam(self) -> list[int]: ...

    @matchesPerCam.setter
    def matchesPerCam(self, arg: Sequence[int], /) -> None: ...

    @property
    def icpInliersRatio(self) -> float: ...

    @icpInliersRatio.setter
    def icpInliersRatio(self, arg: float, /) -> None: ...

    @property
    def icpTranslation(self) -> float: ...

    @icpTranslation.setter
    def icpTranslation(self, arg: float, /) -> None: ...

    @property
    def icpRotation(self) -> float: ...

    @icpRotation.setter
    def icpRotation(self, arg: float, /) -> None: ...

    @property
    def icpStructuralComplexity(self) -> float: ...

    @icpStructuralComplexity.setter
    def icpStructuralComplexity(self, arg: float, /) -> None: ...

    @property
    def icpStructuralDistribution(self) -> float: ...

    @icpStructuralDistribution.setter
    def icpStructuralDistribution(self, arg: float, /) -> None: ...

    @property
    def icpCorrespondences(self) -> int: ...

    @icpCorrespondences.setter
    def icpCorrespondences(self, arg: int, /) -> None: ...

    @property
    def icpRMS(self) -> float: ...

    @icpRMS.setter
    def icpRMS(self, arg: float, /) -> None: ...

class Rtabmap:
    def __init__(self) -> None: ...

    @overload
    def process(self, data: SensorData, odomPose: Transform, odomCovariance: numpy.array, odomVelocity: Sequence[float], externalStats: Mapping[str, float]) -> bool: ...

    @overload
    def process(self, data: SensorData, odomPose: Transform, odomCovariance: numpy.array, odomVelocity: Sequence[float], externalStats: Mapping[str, float]) -> bool: ...

    @overload
    def process(self, data: SensorData, odomPose: Transform, odomLinearVariance: float, odomAngularVariance: float, odomVelocity: Sequence[float], externalStats: Mapping[str, float]) -> bool: ...

    @overload
    def process(self, image: numpy.array, id: int, externalStats: Mapping[str, float]) -> bool: ...

    @overload
    def init(self, parameters: Mapping[str, str], databasePath: str = '', loadDatabaseParameters: bool = False) -> None: ...

    @overload
    def init(self, configFile: str = '', databasePath: str = '', loadDatabaseParameters: bool = False) -> None: ...

    def close(self, databaseSaved: bool = True, ouputDatabasePath: str = '') -> None: ...

    def getWorkingDir(self) -> str: ...

    def isRGBDMode(self) -> bool: ...

    def getLoopClosureId(self) -> int: ...

    def getLoopClosureValue(self) -> float: ...

    def getHighestHypothesisId(self) -> int: ...

    def getHighestHypothesisValue(self) -> float: ...

    def getLastLocationId(self) -> int: ...

    def getWM(self) -> list[int]: ...

    def getSTM(self) -> set[int]: ...

    def getWMSize(self) -> int: ...

    def getSTMSize(self) -> int: ...

    def getWeights(self) -> dict[int, int]: ...

    def getTotalMemSize(self) -> int: ...

    def getLastProcessTime(self) -> float: ...

    def isInSTM(self, locationId: int) -> bool: ...

    def isIDsGenerated(self) -> bool: ...

    def getStatistics(self) -> Statistics: ...

    def getLocalOptimizedPoses(self) -> dict[int, Transform]: ...

    def getPose(self, locationId: int) -> Transform: ...

    def getMapCorrection(self) -> Transform: ...

    def getMemory(self) -> Memory: ...

    def getGoalReachedRadius(self) -> float: ...

    def getLocalRadius(self) -> float: ...

    def getLastLocalizationPose(self) -> Transform: ...

    def getTimeThreshold(self) -> float: ...

    def setTimeThreshold(self, maxTimeAllowed: float) -> None: ...

    def getMemoryThreshold(self) -> int: ...

    def setMemoryThreshold(self, maxMemoryAllowed: int) -> None: ...

    def setInitialPose(self, initialPose: Transform) -> None: ...

    def triggerNewMap(self) -> int: ...

    def labelLocation(self, id: int, label: str) -> bool: ...

    def setUserData(self, id: int, data: numpy.array) -> bool: ...

    def generateDOTGraph(self, path: str, id: int = 0, margin: int = 5) -> None: ...

    def exportPoses(self, path: str, optimized: bool, globals: bool, format: int) -> None: ...

    def resetMemory(self) -> None: ...

    def dumpPrediction(self) -> None: ...

    def dumpData(self) -> None: ...

    def parseParameters(self, parameters: Mapping[str, str]) -> None: ...

    def getParameters(self) -> dict[str, str]: ...

    def setWorkingDirectory(self, path: str) -> None: ...

    def rejectLastLoopClosure(self) -> None: ...

    def deleteLastLocation(self) -> None: ...

    def getSignatureCopy(self, id: int, images: bool, scan: bool, userData: bool, occupancyGrid: bool, withWords: bool, withGlobalDescriptors: bool) -> Signature: ...

    @overload
    def getNodesInRadius(self, pose: Transform, radius: float, k: int, distsSqr: Mapping[int, float]) -> dict[int, Transform]: ...

    @overload
    def getNodesInRadius(self, nodeId: int, radius: float, k: int, distsSqr: Mapping[int, float]) -> dict[int, Transform]: ...

    def detectMoreLoopClosures(self, clusterRadiusMax: float = 0.5, clusterAngle: float = 0.5235987755982988, iterations: int = 1, intraSession: bool = True, interSession: bool = True, state: ProgressState = 0, clusterRadiusMin: float = 0.0) -> int: ...

    def globalBundleAdjustment(self, optimizerType: int = 1, rematchFeatures: bool = True, iterations: int = 0, pixelVariance: float = 0.0) -> bool: ...

    def cleanupLocalGrids(self, mapPoses: Mapping[int, Transform], map: numpy.array, xMin: float, yMin: float, cellSize: float, cropRadius: int = 1, filterScans: bool = False) -> int: ...

    def refineLinks(self) -> int: ...

    def addLink(self, link: Link) -> bool: ...

    def getInformation(self, covariance: numpy.array) -> numpy.array: ...

    def addNodesToRepublish(self, ids: Sequence[int]) -> None: ...

    def getPathStatus(self) -> int: ...

    def clearPath(self, status: int) -> None: ...

    @overload
    def computePath(self, targetNode: int, globals: bool) -> bool: ...

    @overload
    def computePath(self, targetPose: Transform, tolerance: float) -> bool: ...

    def getPath(self) -> list[tuple[int, Transform]]: ...

    def getPathNextPoses(self) -> list[tuple[int, Transform]]: ...

    def getPathNextNodes(self) -> list[int]: ...

    def getPathCurrentGoalId(self) -> int: ...

    def getPathCurrentIndex(self) -> int: ...

    def getPathCurrentGoalIndex(self) -> int: ...

    def getPathTransformToGoal(self) -> Transform: ...

    def getForwardWMPoses(self, fromId: int, maxNearestNeighbors: int, radius: float, maxDiffID: int) -> dict[int, Transform]: ...

    def getPaths(self, poses: Mapping[int, Transform], target: Transform, maxGraphDepth: int = 0) -> dict[int, dict[int, Transform]]: ...

    def adjustLikelihood(self, likelihood: Mapping[int, float]) -> None: ...

class SensorCapture:
    def takeData(self, info: SensorCaptureInfo) -> SensorData: ...

    def init(self, calibrationFolder: str = '.', cameraName: str = '') -> bool: ...

    def getSerial(self) -> str: ...

    def odomProvided(self) -> bool: ...

    def getPose(self, stamp: float, pose: Transform, covariance: numpy.array, maxWaitTime: float = 0.06) -> bool: ...

    def getFrameRate(self) -> float: ...

    def getLocalTransform(self) -> Transform: ...

    def setFrameRate(self, frameRate: float) -> None: ...

    def setLocalTransform(self, localTransform: Transform) -> None: ...

    def resetTimer(self) -> None: ...

class SensorCaptureInfo:
    def __init__(self) -> None: ...

    @property
    def cameraName(self) -> str: ...

    @cameraName.setter
    def cameraName(self, arg: str, /) -> None: ...

    @property
    def id(self) -> int: ...

    @id.setter
    def id(self, arg: int, /) -> None: ...

    @property
    def stamp(self) -> float: ...

    @stamp.setter
    def stamp(self, arg: float, /) -> None: ...

    @property
    def timeCapture(self) -> float: ...

    @timeCapture.setter
    def timeCapture(self, arg: float, /) -> None: ...

    @property
    def timeDeskewing(self) -> float: ...

    @timeDeskewing.setter
    def timeDeskewing(self, arg: float, /) -> None: ...

    @property
    def timeDisparity(self) -> float: ...

    @timeDisparity.setter
    def timeDisparity(self, arg: float, /) -> None: ...

    @property
    def timeMirroring(self) -> float: ...

    @timeMirroring.setter
    def timeMirroring(self, arg: float, /) -> None: ...

    @property
    def timeStereoExposureCompensation(self) -> float: ...

    @timeStereoExposureCompensation.setter
    def timeStereoExposureCompensation(self, arg: float, /) -> None: ...

    @property
    def timeImageDecimation(self) -> float: ...

    @timeImageDecimation.setter
    def timeImageDecimation(self, arg: float, /) -> None: ...

    @property
    def timeHistogramEqualization(self) -> float: ...

    @timeHistogramEqualization.setter
    def timeHistogramEqualization(self, arg: float, /) -> None: ...

    @property
    def timeScanFromDepth(self) -> float: ...

    @timeScanFromDepth.setter
    def timeScanFromDepth(self, arg: float, /) -> None: ...

    @property
    def timeUndistortDepth(self) -> float: ...

    @timeUndistortDepth.setter
    def timeUndistortDepth(self, arg: float, /) -> None: ...

    @property
    def timeBilateralFiltering(self) -> float: ...

    @timeBilateralFiltering.setter
    def timeBilateralFiltering(self, arg: float, /) -> None: ...

    @property
    def timeTotal(self) -> float: ...

    @timeTotal.setter
    def timeTotal(self, arg: float, /) -> None: ...

    @property
    def odomPose(self) -> Transform: ...

    @odomPose.setter
    def odomPose(self, arg: Transform, /) -> None: ...

    @property
    def odomCovariance(self) -> numpy.array: ...

    @odomCovariance.setter
    def odomCovariance(self, arg: numpy.array, /) -> None: ...

    @property
    def odomVelocity(self) -> list[float]: ...

    @odomVelocity.setter
    def odomVelocity(self, arg: Sequence[float], /) -> None: ...

class SensorData:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, image: numpy.array, id: int, stamp: float) -> None: ...

    @overload
    def __init__(self, image: numpy.array, cameraModel: CameraModel, id: int, stamp: float) -> None: ...

    @overload
    def __init__(self, rgb: numpy.array, depth: numpy.array, cameraModel: CameraModel, id: int, stamp: float) -> None: ...

    @overload
    def __init__(self, laserScan: LaserScan, rgb: numpy.array, depth: numpy.array, cameraModel: CameraModel, id: int, stamp: float) -> None: ...

    @overload
    def __init__(self, laserScan: LaserScan, rgb: numpy.array, depth: numpy.array, depthConfidence: numpy.array, cameraModel: CameraModel, id: int, stamp: float) -> None: ...

    @overload
    def __init__(self, rgb: numpy.array, depth: numpy.array, cameraModel: Sequence[CameraModel], id: int, stamp: float) -> None: ...

    @overload
    def __init__(self, rgb: numpy.array, depth: numpy.array, depthConfidence: numpy.array, cameraModel: Sequence[CameraModel], id: int, stamp: float) -> None: ...

    @overload
    def __init__(self, laserScan: LaserScan, rgb: numpy.array, depth: numpy.array, cameraModel: Sequence[CameraModel], id: int, stamp: float) -> None: ...

    @overload
    def __init__(self, laserScan: LaserScan, rgb: numpy.array, depth: numpy.array, depthConfidence: numpy.array, cameraModel: Sequence[CameraModel], id: int, stamp: float) -> None: ...

    @overload
    def __init__(self, left: numpy.array, right: numpy.array, cameraModel: StereoCameraModel, id: int, stamp: float) -> None: ...

    @overload
    def __init__(self, laserScan: LaserScan, left: numpy.array, right: numpy.array, cameraModel: StereoCameraModel, id: int, stamp: float) -> None: ...

    @overload
    def __init__(self, rgb: numpy.array, depth: numpy.array, cameraModel: Sequence[StereoCameraModel], id: int, stamp: float) -> None: ...

    @overload
    def __init__(self, laserScan: LaserScan, rgb: numpy.array, depth: numpy.array, cameraModel: Sequence[StereoCameraModel], id: int, stamp: float) -> None: ...

    @overload
    def __init__(self, imu: IMU, id: int, stamp: float) -> None: ...

    def isValid(self) -> bool: ...

    def id(self) -> int: ...

    def setId(self, id: int) -> None: ...

    def stamp(self) -> float: ...

    def setStamp(self, stamp: float) -> None: ...

    def imageCompressed(self) -> numpy.array: ...

    def depthOrRightCompressed(self) -> numpy.array: ...

    def depthConfidenceCompressed(self) -> numpy.array: ...

    def laserScanCompressed(self) -> LaserScan: ...

    def imageRaw(self) -> numpy.array: ...

    def depthOrRightRaw(self) -> numpy.array: ...

    def depthConfidenceRaw(self) -> numpy.array: ...

    def laserScanRaw(self) -> LaserScan: ...

    @overload
    def setRGBDImage(self, rgb: numpy.array, depth: numpy.array, model: CameraModel, clearPreviousData: bool = True) -> None: ...

    @overload
    def setRGBDImage(self, rgb: numpy.array, depth: numpy.array, model: CameraModel, clearPreviousData: bool = True) -> None: ...

    @overload
    def setRGBDImage(self, rgb: numpy.array, depth: numpy.array, models: Sequence[CameraModel], clearPreviousData: bool = True) -> None: ...

    @overload
    def setRGBDImage(self, rgb: numpy.array, depth: numpy.array, depth_confidence: numpy.array, model: CameraModel, clearPreviousData: bool = True) -> None: ...

    @overload
    def setStereoImage(self, left: numpy.array, right: numpy.array, stereoCameraModel: StereoCameraModel, clearPreviousData: bool = True) -> None: ...

    @overload
    def setStereoImage(self, left: numpy.array, right: numpy.array, stereoCameraModel: Sequence[StereoCameraModel], clearPreviousData: bool = True) -> None: ...

    def setLaserScan(self, laserScan: LaserScan, clearPreviousData: bool = True) -> None: ...

    def setCameraModel(self, model: CameraModel) -> None: ...

    def setCameraModels(self, models: Sequence[CameraModel]) -> None: ...

    def setStereoCameraModel(self, stereoCameraModel: StereoCameraModel) -> None: ...

    def setStereoCameraModels(self, stereoCameraModels: Sequence[StereoCameraModel]) -> None: ...

    def depthRaw(self) -> numpy.array: ...

    def rightRaw(self) -> numpy.array: ...

    def uncompressData(self) -> None: ...

    def cameraModels(self) -> list[CameraModel]: ...

    def stereoCameraModels(self) -> list[StereoCameraModel]: ...

    def setUserData(self, userData: numpy.array, clearPreviousData: bool = True) -> None: ...

    def userDataRaw(self) -> numpy.array: ...

    def userDataCompressed(self) -> numpy.array: ...

    def setOccupancyGrid(self, ground: numpy.array, obstacles: numpy.array, empty: numpy.array, cellSize: float, viewPoint: tuple) -> None: ...

    def clearOccupancyGridRaw(self) -> None: ...

    def gridGroundCellsRaw(self) -> numpy.array: ...

    def gridGroundCellsCompressed(self) -> numpy.array: ...

    def gridObstacleCellsRaw(self) -> numpy.array: ...

    def gridObstacleCellsCompressed(self) -> numpy.array: ...

    def gridEmptyCellsRaw(self) -> numpy.array: ...

    def gridEmptyCellsCompressed(self) -> numpy.array: ...

    def gridCellSize(self) -> float: ...

    def gridViewPoint(self) -> tuple: ...

    def setFeatures(self, keypoints: Sequence["cv::KeyPoint"], keypoints3D: Sequence[tuple], descriptors: numpy.array) -> None: ...

    def keypoints(self) -> list["cv::KeyPoint"]: ...

    def keypoints3D(self) -> list[tuple]: ...

    def descriptors(self) -> numpy.array: ...

    def addGlobalDescriptor(self, descriptor: GlobalDescriptor) -> None: ...

    def setGlobalDescriptors(self, descriptors: Sequence[GlobalDescriptor]) -> None: ...

    def clearGlobalDescriptors(self) -> None: ...

    def globalDescriptors(self) -> list[GlobalDescriptor]: ...

    def setGroundTruth(self, pose: Transform) -> None: ...

    def groundTruth(self) -> Transform: ...

    def setGlobalPose(self, pose: Transform, covariance: numpy.array) -> None: ...

    def globalPose(self) -> Transform: ...

    def globalPoseCovariance(self) -> numpy.array: ...

    def setGPS(self, gps: GPS) -> None: ...

    def gps(self) -> GPS: ...

    def setIMU(self, imu: IMU) -> None: ...

    def imu(self) -> IMU: ...

    def setEnvSensors(self, sensors: Mapping[EnvSensorType, EnvSensor]) -> None: ...

    def addEnvSensor(self, sensor: EnvSensor) -> None: ...

    def envSensors(self) -> dict[EnvSensorType, EnvSensor]: ...

    def setLandmarks(self, landmarks: Mapping[int, Landmark]) -> None: ...

    def landmarks(self) -> dict[int, Landmark]: ...

    def getMemoryUsed(self) -> int: ...

    def clearCompressedData(self, images: bool = True, scan: bool = True, userData: bool = True) -> None: ...

    def clearRawData(self, images: bool = True, scan: bool = True, userData: bool = True) -> None: ...

    def isPointVisibleFromCameras(self, pt: tuple) -> bool: ...

class Signature:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, id: int) -> None: ...

    def compareTo(self, signature: Signature) -> float: ...

    def isBadSignature(self) -> bool: ...

    @overload
    def id(self) -> int: ...

    @overload
    def id(self) -> int: ...

    def mapId(self) -> int: ...

    def setWeight(self, weight: int) -> None: ...

    def getWeight(self) -> int: ...

    def setLabel(self, label: str) -> None: ...

    def getLabel(self) -> str: ...

    def getStamp(self) -> float: ...

    @overload
    def addLinks(self, links: Sequence[Link]) -> None: ...

    @overload
    def addLinks(self, links: Mapping[int, Link]) -> None: ...

    def addLink(self, link: Link) -> None: ...

    def hasLink(self, idTo: int, type: LinkType) -> bool: ...

    def changeLinkIds(self, idFrom: int, idTo: int) -> None: ...

    def removeLinks(self, keepSelfReferringLinks: bool = False) -> None: ...

    def removeLink(self, idTo: int) -> None: ...

    def removeVirtualLinks(self) -> None: ...

    def addLandmark(self, landmark: Link) -> None: ...

    def getLandmarks(self) -> dict[int, Link]: ...

    def removeLandmarks(self) -> None: ...

    def removeLandmark(self, landmarkId: int) -> None: ...

    def setSaved(self, saved: bool) -> None: ...

    def setModified(self, modified: bool) -> None: ...

    def isSaved(self) -> bool: ...

    def isModified(self) -> bool: ...

    def isLinksModified(self) -> bool: ...

    def removeAllWords(self) -> None: ...

    def changeWordsRef(self, oldWordId: int, activeWordId: int) -> None: ...

    def isEnabled(self) -> bool: ...

    def setEnabled(self, enabled: bool) -> None: ...

    def getWordsKpts(self) -> list["cv::KeyPoint"]: ...

    def getInvalidWordsCount(self) -> int: ...

    def getWordsChanged(self) -> dict[int, int]: ...

    def getWordsDescriptors(self) -> numpy.array: ...

    def setWordsDescriptors(self, descriptors: numpy.array) -> None: ...

    def setPose(self, pose: Transform) -> None: ...

    def setGroundTruthPose(self, pose: Transform) -> None: ...

    def setVelocity(self, vx: float, vy: float, vz: float, vroll: float, vpitch: float, vyaw: float) -> None: ...

    def getWords3(self) -> list[tuple]: ...

    def getPose(self) -> Transform: ...

    def getPoseCovariance(self) -> numpy.array: ...

    def getGroundTruthPose(self) -> Transform: ...

    def getVelocity(self) -> list[float]: ...

    def sensorData(self) -> SensorData: ...

    def getMemoryUsed(self, withSensorData: bool = True) -> int: ...

class Statistics:
    def __init__(self) -> None: ...

    @staticmethod
    def kLoopId() -> str: ...

    @staticmethod
    def kLoopRejectedHypothesis() -> str: ...

    @staticmethod
    def kLoopAccepted_hypothesis_id() -> str: ...

    @staticmethod
    def kLoopSuppressed_hypothesis_id() -> str: ...

    @staticmethod
    def kLoopHighest_hypothesis_id() -> str: ...

    @staticmethod
    def kLoopHighest_hypothesis_value() -> str: ...

    @staticmethod
    def kLoopVp_hypothesis() -> str: ...

    @staticmethod
    def kLoopReactivate_id() -> str: ...

    @staticmethod
    def kLoopHypothesis_ratio() -> str: ...

    @staticmethod
    def kLoopHypothesis_reactivated() -> str: ...

    @staticmethod
    def kLoopMap_id() -> str: ...

    @staticmethod
    def kLoopVisual_words() -> str: ...

    @staticmethod
    def kLoopVisual_inliers() -> str: ...

    @staticmethod
    def kLoopVisual_inliers_ratio() -> str: ...

    @staticmethod
    def kLoopVisual_matches() -> str: ...

    @staticmethod
    def kLoopDistance_since_last_loc() -> str: ...

    @staticmethod
    def kLoopLast_id() -> str: ...

    @staticmethod
    def kLoopOptimization_max_error() -> str: ...

    @staticmethod
    def kLoopOptimization_max_error_ratio() -> str: ...

    @staticmethod
    def kLoopOptimization_max_ang_error() -> str: ...

    @staticmethod
    def kLoopOptimization_max_ang_error_ratio() -> str: ...

    @staticmethod
    def kLoopOptimization_error() -> str: ...

    @staticmethod
    def kLoopOptimization_iterations() -> str: ...

    @staticmethod
    def kLoopLinear_variance() -> str: ...

    @staticmethod
    def kLoopAngular_variance() -> str: ...

    @staticmethod
    def kLoopLandmark_detected() -> str: ...

    @staticmethod
    def kLoopLandmark_detected_node_ref() -> str: ...

    @staticmethod
    def kLoopVisual_inliers_mean_dist() -> str: ...

    @staticmethod
    def kLoopVisual_inliers_distribution() -> str: ...

    @staticmethod
    def kLoopProximity_links_cleared() -> str: ...

    @staticmethod
    def kLoopOdom_correction_norm() -> str: ...

    @staticmethod
    def kLoopOdom_correction_angle() -> str: ...

    @staticmethod
    def kLoopOdom_correction_x() -> str: ...

    @staticmethod
    def kLoopOdom_correction_y() -> str: ...

    @staticmethod
    def kLoopOdom_correction_z() -> str: ...

    @staticmethod
    def kLoopOdom_correction_roll() -> str: ...

    @staticmethod
    def kLoopOdom_correction_pitch() -> str: ...

    @staticmethod
    def kLoopOdom_correction_yaw() -> str: ...

    @staticmethod
    def kLoopMapToOdom_norm() -> str: ...

    @staticmethod
    def kLoopMapToOdom_angle() -> str: ...

    @staticmethod
    def kLoopMapToOdom_x() -> str: ...

    @staticmethod
    def kLoopMapToOdom_y() -> str: ...

    @staticmethod
    def kLoopMapToOdom_z() -> str: ...

    @staticmethod
    def kLoopMapToOdom_roll() -> str: ...

    @staticmethod
    def kLoopMapToOdom_yaw() -> str: ...

    @staticmethod
    def kLoopMapToOdom_pitch() -> str: ...

    @staticmethod
    def kLoopMapToBase_x() -> str: ...

    @staticmethod
    def kLoopMapToBase_y() -> str: ...

    @staticmethod
    def kLoopMapToBase_z() -> str: ...

    @staticmethod
    def kLoopMapToBase_roll() -> str: ...

    @staticmethod
    def kLoopMapToBase_pitch() -> str: ...

    @staticmethod
    def kLoopMapToBase_yaw() -> str: ...

    @staticmethod
    def kLoopMapToBase_lin_std() -> str: ...

    @staticmethod
    def kLoopMapToBase_lin_var() -> str: ...

    @staticmethod
    def kProximityTime_detections() -> str: ...

    @staticmethod
    def kProximitySpace_last_detection_id() -> str: ...

    @staticmethod
    def kProximitySpace_paths() -> str: ...

    @staticmethod
    def kProximitySpace_visual_paths_checked() -> str: ...

    @staticmethod
    def kProximitySpace_scan_paths_checked() -> str: ...

    @staticmethod
    def kProximitySpace_detections_added_visually() -> str: ...

    @staticmethod
    def kProximitySpace_detections_added_icp_multi() -> str: ...

    @staticmethod
    def kProximitySpace_detections_added_icp_global() -> str: ...

    @staticmethod
    def kNeighborLinkRefiningAccepted() -> str: ...

    @staticmethod
    def kNeighborLinkRefiningInliers() -> str: ...

    @staticmethod
    def kNeighborLinkRefiningICP_inliers_ratio() -> str: ...

    @staticmethod
    def kNeighborLinkRefiningICP_rotation() -> str: ...

    @staticmethod
    def kNeighborLinkRefiningICP_translation() -> str: ...

    @staticmethod
    def kNeighborLinkRefiningICP_complexity() -> str: ...

    @staticmethod
    def kNeighborLinkRefiningVariance() -> str: ...

    @staticmethod
    def kNeighborLinkRefiningPts() -> str: ...

    @staticmethod
    def kMemoryWorking_memory_size() -> str: ...

    @staticmethod
    def kMemoryShort_time_memory_size() -> str: ...

    @staticmethod
    def kMemoryDatabase_memory_used() -> str: ...

    @staticmethod
    def kMemorySignatures_removed() -> str: ...

    @staticmethod
    def kMemoryImmunized_globally() -> str: ...

    @staticmethod
    def kMemoryImmunized_locally() -> str: ...

    @staticmethod
    def kMemoryImmunized_locally_max() -> str: ...

    @staticmethod
    def kMemorySignatures_retrieved() -> str: ...

    @staticmethod
    def kMemoryImages_buffered() -> str: ...

    @staticmethod
    def kMemoryRehearsal_sim() -> str: ...

    @staticmethod
    def kMemoryRehearsal_id() -> str: ...

    @staticmethod
    def kMemoryRehearsal_merged() -> str: ...

    @staticmethod
    def kMemoryLocal_graph_size() -> str: ...

    @staticmethod
    def kMemoryOdom_cache_poses() -> str: ...

    @staticmethod
    def kMemoryOdom_cache_links() -> str: ...

    @staticmethod
    def kMemorySmall_movement() -> str: ...

    @staticmethod
    def kMemoryFast_movement() -> str: ...

    @staticmethod
    def kMemoryNew_landmark() -> str: ...

    @staticmethod
    def kMemoryOdometry_variance_ang() -> str: ...

    @staticmethod
    def kMemoryOdometry_variance_lin() -> str: ...

    @staticmethod
    def kMemoryDistance_travelled() -> str: ...

    @staticmethod
    def kMemoryRAM_usage() -> str: ...

    @staticmethod
    def kMemoryRAM_estimated() -> str: ...

    @staticmethod
    def kMemoryTriangulated_points() -> str: ...

    @staticmethod
    def kMemoryClosest_node_distance() -> str: ...

    @staticmethod
    def kMemoryClosest_node_angle() -> str: ...

    @staticmethod
    def kTimingMemory_update() -> str: ...

    @staticmethod
    def kTimingNeighbor_link_refining() -> str: ...

    @staticmethod
    def kTimingProximity_by_time() -> str: ...

    @staticmethod
    def kTimingProximity_by_space_search() -> str: ...

    @staticmethod
    def kTimingProximity_by_space_visual() -> str: ...

    @staticmethod
    def kTimingProximity_by_space() -> str: ...

    @staticmethod
    def kTimingCleaning_neighbors() -> str: ...

    @staticmethod
    def kTimingReactivation() -> str: ...

    @staticmethod
    def kTimingAdd_loop_closure_link() -> str: ...

    @staticmethod
    def kTimingMap_optimization() -> str: ...

    @staticmethod
    def kTimingLikelihood_computation() -> str: ...

    @staticmethod
    def kTimingPosterior_computation() -> str: ...

    @staticmethod
    def kTimingHypotheses_creation() -> str: ...

    @staticmethod
    def kTimingHypotheses_validation() -> str: ...

    @staticmethod
    def kTimingStatistics_creation() -> str: ...

    @staticmethod
    def kTimingMemory_cleanup() -> str: ...

    @staticmethod
    def kTimingTotal() -> str: ...

    @staticmethod
    def kTimingForgetting() -> str: ...

    @staticmethod
    def kTimingJoining_trash() -> str: ...

    @staticmethod
    def kTimingEmptying_trash() -> str: ...

    @staticmethod
    def kTimingFinalizing_statistics() -> str: ...

    @staticmethod
    def kTimingRAM_estimation() -> str: ...

    @staticmethod
    def kTimingMemPre_update() -> str: ...

    @staticmethod
    def kTimingMemSignature_creation() -> str: ...

    @staticmethod
    def kTimingMemRehearsal() -> str: ...

    @staticmethod
    def kTimingMemKeypoints_detection() -> str: ...

    @staticmethod
    def kTimingMemSubpixel() -> str: ...

    @staticmethod
    def kTimingMemStereo_correspondences() -> str: ...

    @staticmethod
    def kTimingMemDescriptors_extraction() -> str: ...

    @staticmethod
    def kTimingMemRectification() -> str: ...

    @staticmethod
    def kTimingMemKeypoints_3D() -> str: ...

    @staticmethod
    def kTimingMemKeypoints_3D_motion() -> str: ...

    @staticmethod
    def kTimingMemJoining_dictionary_update() -> str: ...

    @staticmethod
    def kTimingMemAdd_new_words() -> str: ...

    @staticmethod
    def kTimingMemCompressing_data() -> str: ...

    @staticmethod
    def kTimingMemPost_decimation() -> str: ...

    @staticmethod
    def kTimingMemScan_filtering() -> str: ...

    @staticmethod
    def kTimingMemOccupancy_grid() -> str: ...

    @staticmethod
    def kTimingMemMarkers_detection() -> str: ...

    @staticmethod
    def kKeypointDictionary_size() -> str: ...

    @staticmethod
    def kKeypointCurrent_frame() -> str: ...

    @staticmethod
    def kKeypointIndexed_words() -> str: ...

    @staticmethod
    def kKeypointIndex_memory_usage() -> str: ...

    @staticmethod
    def kGtTranslational_rmse() -> str: ...

    @staticmethod
    def kGtTranslational_mean() -> str: ...

    @staticmethod
    def kGtTranslational_median() -> str: ...

    @staticmethod
    def kGtTranslational_std() -> str: ...

    @staticmethod
    def kGtTranslational_min() -> str: ...

    @staticmethod
    def kGtTranslational_max() -> str: ...

    @staticmethod
    def kGtRotational_rmse() -> str: ...

    @staticmethod
    def kGtRotational_mean() -> str: ...

    @staticmethod
    def kGtRotational_median() -> str: ...

    @staticmethod
    def kGtRotational_std() -> str: ...

    @staticmethod
    def kGtRotational_min() -> str: ...

    @staticmethod
    def kGtRotational_max() -> str: ...

    @staticmethod
    def kGtLocalization_linear_error() -> str: ...

    @staticmethod
    def kGtLocalization_angular_error() -> str: ...

    @staticmethod
    def defaultData() -> dict[str, float]: ...

    @staticmethod
    def serializeData(data: Mapping[str, float]) -> str: ...

    @staticmethod
    def deserializeData(data: str) -> dict[str, float]: ...

    def addStatistic(self, name: str, value: float) -> None: ...

    def setExtended(self, extended: bool) -> None: ...

    def setRefImageId(self, id: int) -> None: ...

    def setRefImageMapId(self, id: int) -> None: ...

    def setLoopClosureId(self, id: int) -> None: ...

    def setLoopClosureMapId(self, id: int) -> None: ...

    def setProximityDetectionId(self, id: int) -> None: ...

    def setProximityDetectionMapId(self, id: int) -> None: ...

    def setStamp(self, stamp: float) -> None: ...

    def addSignatureData(self, data: Signature) -> None: ...

    def setSignaturesData(self, data: Mapping[int, Signature]) -> None: ...

    def setPoses(self, poses: Mapping[int, Transform]) -> None: ...

    def setMapCorrection(self, mapCorrection: Transform) -> None: ...

    def setLoopClosureTransform(self, loopClosureTransform: Transform) -> None: ...

    def setLocalizationCovariance(self, covariance: numpy.array) -> None: ...

    def setLabels(self, labels: Mapping[int, str]) -> None: ...

    def setWeights(self, weights: Mapping[int, int]) -> None: ...

    def setPosterior(self, posterior: Mapping[int, float]) -> None: ...

    def setLikelihood(self, likelihood: Mapping[int, float]) -> None: ...

    def setRawLikelihood(self, rawLikelihood: Mapping[int, float]) -> None: ...

    def setLocalPath(self, localPath: Sequence[int]) -> None: ...

    def setCurrentGoalId(self, goal: int) -> None: ...

    def setReducedIds(self, reducedIds: Mapping[int, int]) -> None: ...

    def setWmState(self, state: Sequence[int]) -> None: ...

    def setOdomCachePoses(self, poses: Mapping[int, Transform]) -> None: ...

    def extended(self) -> bool: ...

    def refImageId(self) -> int: ...

    def refImageMapId(self) -> int: ...

    def loopClosureId(self) -> int: ...

    def loopClosureMapId(self) -> int: ...

    def proximityDetectionId(self) -> int: ...

    def proximityDetectionMapId(self) -> int: ...

    def stamp(self) -> float: ...

    def getLastSignatureData(self) -> Signature: ...

    def getSignaturesData(self) -> dict[int, Signature]: ...

    def poses(self) -> dict[int, Transform]: ...

    def mapCorrection(self) -> Transform: ...

    def loopClosureTransform(self) -> Transform: ...

    def localizationCovariance(self) -> numpy.array: ...

    def labels(self) -> dict[int, str]: ...

    def weights(self) -> dict[int, int]: ...

    def posterior(self) -> dict[int, float]: ...

    def likelihood(self) -> dict[int, float]: ...

    def rawLikelihood(self) -> dict[int, float]: ...

    def localPath(self) -> list[int]: ...

    def currentGoalId(self) -> int: ...

    def reducedIds(self) -> dict[int, int]: ...

    def wmState(self) -> list[int]: ...

    def odomCachePoses(self) -> dict[int, Transform]: ...

    def data(self) -> dict[str, float]: ...

class StereoCameraModel:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, name: str, imageSize1: tuple, K1: numpy.array, D1: numpy.array, R1: numpy.array, P1: numpy.array, imageSize2: tuple, K2: numpy.array, D2: numpy.array, R2: numpy.array, P2: numpy.array, R: numpy.array, T: numpy.array, E: numpy.array, F: numpy.array) -> None: ...

    @overload
    def __init__(self, name: str, leftCameraModel: CameraModel, rightCameraModel: CameraModel) -> None: ...

    @overload
    def __init__(self, name: str, leftCameraModel: CameraModel, rightCameraModel: CameraModel, extrinsics: Transform) -> None: ...

    @overload
    def __init__(self, fx: float, fy: float, cx: float, cy: float, baseline: float) -> None: ...

    @overload
    def __init__(self, name: str, fx: float, fy: float, cx: float, cy: float, baseline: float) -> None: ...

    def isValidForProjection(self) -> bool: ...

    def isValidForRectification(self) -> bool: ...

    def initRectificationMap(self) -> None: ...

    def isRectificationMapInitialized(self) -> bool: ...

    def setName(self, name: str, leftSuffix: str = 'left', rightSuffix: str = 'right') -> None: ...

    def name(self) -> str: ...

    def setImageSize(self, size: tuple) -> None: ...

    def load(self, directory: str, cameraName: str, ignoreStereoTransform: bool = True) -> bool: ...

    def save(self, directory: str, ignoreStereoTransform: bool = True) -> bool: ...

    def saveStereoTransform(self, directory: str) -> bool: ...

    def serialize(self) -> list[int]: ...

    def deserialize(self, data: Sequence[int]) -> int: ...

    def baseline(self) -> float: ...

    def computeDepth(self, disparity: float) -> float: ...

    @overload
    def computeDisparity(self, depth: float) -> float: ...

    @overload
    def computeDisparity(self, depth: int) -> float: ...

    def R(self) -> numpy.array: ...

    def T(self) -> numpy.array: ...

    def E(self) -> numpy.array: ...

    def F(self) -> numpy.array: ...

    def scale(self, scale: float) -> None: ...

    def roi(self, roi: tuple) -> None: ...

    def setLocalTransform(self, transform: Transform) -> None: ...

    def localTransform(self) -> Transform: ...

    def stereoTransform(self) -> Transform: ...

    def left(self) -> CameraModel: ...

    def right(self) -> CameraModel: ...

    def getLeftSuffix(self) -> str: ...

    def getRightSuffix(self) -> str: ...

class Transform:
    @overload
    def __init__(self, r11: float, r12: float, r13: float, o14: float, r21: float, r22: float, r23: float, o24: float, r31: float, r32: float, r33: float, o34: float) -> None: ...

    @overload
    def __init__(self, transformationMatrix: numpy.array) -> None: ...

    @overload
    def __init__(self, x: float, y: float, z: float, roll: float, pitch: float, yaw: float) -> None: ...

    @overload
    def __init__(self, x: float, y: float, z: float, qx: float, qy: float, qz: float, qw: float) -> None: ...

    @overload
    def __init__(self, x: float, y: float, theta: float) -> None: ...

    def clone(self) -> Transform: ...

    def r11(self) -> float: ...

    def r12(self) -> float: ...

    def r13(self) -> float: ...

    def r21(self) -> float: ...

    def r22(self) -> float: ...

    def r23(self) -> float: ...

    def r31(self) -> float: ...

    def r32(self) -> float: ...

    def r33(self) -> float: ...

    def o14(self) -> float: ...

    def o24(self) -> float: ...

    def o34(self) -> float: ...

    def isNull(self) -> bool: ...

    def isIdentity(self) -> bool: ...

    def setNull(self) -> None: ...

    def setIdentity(self) -> None: ...

    def size(self) -> int: ...

    def theta(self) -> float: ...

    def isInvertible(self) -> bool: ...

    def inverse(self) -> Transform: ...

    def rotation(self) -> Transform: ...

    def translation(self) -> Transform: ...

    def to3DoF(self) -> Transform: ...

    def to4DoF(self) -> Transform: ...

    def is3DoF(self) -> bool: ...

    def is4DoF(self) -> bool: ...

    def rotationMatrix(self) -> numpy.array: ...

    def translationMatrix(self) -> numpy.array: ...

    def getTranslationAndEulerAngles(self) -> tuple[float, float, float, float, float, float]: ...

    def getEulerAngles(self) -> tuple[float, float, float]: ...

    def getTranslation(self) -> tuple[float, float, float]: ...

    def getAngle(self, t: Transform) -> float: ...

    def getNorm(self) -> float: ...

    def getNormSquared(self) -> float: ...

    def getDistance(self, t: Transform) -> float: ...

    def getDistanceSquared(self, t: Transform) -> float: ...

    def interpolate(self, t: float, other: Transform) -> Transform: ...

    def normalizeRotation(self) -> None: ...

    def prettyPrint(self) -> str: ...

    def __str__(self) -> str: ...

    def toEigen4f(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(4, 4), order='F')]: ...

    def toEigen4d(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(4, 4), order='F')]: ...

    @staticmethod
    def getIdentity() -> Transform: ...

    @staticmethod
    def fromEigen4f(matrix: Annotated[ArrayLike, dict(dtype='float32', shape=(4, 4), order='F')]) -> Transform: ...

    @staticmethod
    def fromEigen4d(matrix: Annotated[ArrayLike, dict(dtype='float64', shape=(4, 4), order='F')]) -> Transform: ...

    @staticmethod
    def opengl_T_rtabmap() -> Transform: ...

    @staticmethod
    def rtabmap_T_opengl() -> Transform: ...

    @staticmethod
    def fromString(string: str) -> Transform: ...

    @staticmethod
    def canParseString(string: str) -> bool: ...

    @staticmethod
    def getTransform(tfBuffer: Mapping[float, Transform], stamp: float) -> Transform: ...

class VWDictionary:
    def __init__(self) -> None: ...

    def parseParameters(self, parameters: Mapping[str, str]) -> None: ...

    def update(self) -> None: ...

    def addNewWords(self, descriptors: numpy.array, signatureId: int) -> list[int]: ...

    def addWord(self, vw: VisualWord) -> None: ...

    def findNN(self, vws: numpy.array) -> list[int]: ...

    def addWordRef(self, wordId: int, signatureId: int) -> None: ...

    def removeAllWordRef(self, wordId: int, signatureId: int) -> None: ...

    def getWord(self, id: int) -> VisualWord: ...

    def getUnusedWord(self, id: int) -> VisualWord: ...

    def setLastWordId(self, id: int) -> None: ...

    def getVisualWords(self) -> dict[int, VisualWord]: ...

    def getNndrRatio(self) -> float: ...

    def getNotIndexedWordsCount(self) -> int: ...

    def getLastIndexedWordId(self) -> int: ...

    def getTotalActiveReferences(self) -> int: ...

    def getIndexedWordsCount(self) -> int: ...

    def getIndexMemoryUsed(self) -> int: ...

    def getMemoryUsed(self) -> int: ...

    def setNNStrategy(self, strategy: NNStrategy) -> bool: ...

    def isIncremental(self) -> bool: ...

    def isIncrementalFlann(self) -> bool: ...

    def setIncrementalDictionary(self) -> None: ...

    def setFixedDictionary(self, dictionaryPath: str) -> None: ...

    def isModified(self) -> bool: ...

    def serializeIndex(self) -> list[int]: ...

    def deserializeIndex(self, data: Sequence[int]) -> None: ...

    def exportDictionary(self, fileNameReferences: str, fileNameDescriptors: str) -> None: ...

    def clear(self, printWarningsIfNotEmpty: bool = True) -> None: ...

    def getUnusedWords(self) -> list[VisualWord]: ...

    def getUnusedWordIds(self) -> list[int]: ...

    def getUnusedWordsSize(self) -> int: ...

    def removeWords(self, words: Sequence[VisualWord]) -> None: ...

    def deleteUnusedWords(self) -> None: ...

    @staticmethod
    def convertBinTo32F(descriptorsIn: numpy.array, byteToFloat: bool = True) -> numpy.array: ...

    @staticmethod
    def convert32FToBin(descriptorsIn: numpy.array, byteToFloat: bool = True) -> numpy.array: ...

class VisualWord:
    def __init__(self, id: int, descriptor: numpy.array, signatureId: int = 0) -> None: ...

    def addRef(self, signatureId: int) -> None: ...

    def removeAllRef(self, signatureId: int) -> int: ...

    def getMemoryUsed(self) -> int: ...

    def getTotalReferences(self) -> int: ...

    def id(self) -> int: ...

    def getDescriptor(self) -> numpy.array: ...

    def getReferences(self) -> dict[int, int]: ...

    def isSaved(self) -> bool: ...

    def setSaved(self, saved: bool) -> None: ...
