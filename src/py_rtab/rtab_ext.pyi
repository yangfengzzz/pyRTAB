from collections.abc import Mapping, Sequence, Set
import enum
from typing import Annotated, overload

import numpy
from numpy.typing import ArrayLike


class CameraModel:
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: Transform, arg5: float, arg6: "cv::Size_<int>", /) -> None: ...

    @overload
    def __init__(self, arg0: str, arg1: float, arg2: float, arg3: float, arg4: float, arg5: Transform, arg6: float, arg7: "cv::Size_<int>", /) -> None: ...

    @staticmethod
    def opticalRotation() -> Transform: ...

    def initRectificationMap(self) -> bool: ...

    def isRectificationMapInitialized(self) -> bool: ...

    def isValidForProjection(self) -> bool: ...

    def isValidForReprojection(self) -> bool: ...

    def isValidForRectification(self) -> bool: ...

    def setName(self, arg: str, /) -> None: ...

    def name(self) -> str: ...

    def fx(self) -> float: ...

    def fy(self) -> float: ...

    def cx(self) -> float: ...

    def cy(self) -> float: ...

    def Tx(self) -> float: ...

    def setLocalTransform(self, arg: Transform, /) -> None: ...

    def localTransform(self) -> Transform: ...

    def setImageSize(self, arg: "cv::Size_<int>", /) -> None: ...

    def imageSize(self) -> "cv::Size_<int>": ...

    def imageWidth(self) -> int: ...

    def imageHeight(self) -> int: ...

    def fovX(self) -> float: ...

    def fovY(self) -> float: ...

    def horizontalFOV(self) -> float: ...

    def verticalFOV(self) -> float: ...

    def isFisheye(self) -> bool: ...

    @overload
    def load(self, arg: str, /) -> bool: ...

    @overload
    def load(self, arg0: str, arg1: str, /) -> bool: ...

    def save(self, arg: str, /) -> bool: ...

    def serialize(self) -> list[int]: ...

    def deserialize(self, arg: Sequence[int], /) -> int: ...

    def scaled(self, arg: float, /) -> CameraModel: ...

    def roi(self, arg: "cv::Rect_<int>", /) -> CameraModel: ...

    def project(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, /) -> None: ...

    def inFrame(self, arg0: int, arg1: int, /) -> bool: ...

class EnvSensor:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, type: EnvSensorType, value: float, stamp: float = 0) -> None: ...

    def type(self) -> EnvSensorType: ...

    def value(self) -> float: ...

    def stamp(self) -> float: ...

class EnvSensorType(enum.Enum):
    kUndefined = 0

    kWifiSignalStrength = 1

    kAmbientTemperature = 2

    kAmbientAirPressure = 3

    kAmbientLight = 4

    kAmbientRelativeHumidity = 5

    kCustomSensor1 = 100

    kCustomSensor2 = 101

    kCustomSensor3 = 102

    kCustomSensor4 = 103

    kCustomSensor5 = 104

    kCustomSensor6 = 105

    kCustomSensor7 = 106

    kCustomSensor8 = 107

    kCustomSensor9 = 108

class Feature2D:
    @staticmethod
    def create(arg: Feature2DType, /) -> Feature2D: ...

    def getMaxFeatures(self) -> int: ...

    def getSSC(self) -> bool: ...

    def getMinDepth(self) -> float: ...

    def getMaxDepth(self) -> float: ...

    def getGridRows(self) -> int: ...

    def getGridCols(self) -> int: ...

class Feature2DType(enum.Enum):
    kFeatureUndef = -1

    kFeatureSurf = 0

    kFeatureSift = 1

    kFeatureOrb = 2

    kFeatureFastFreak = 3

    kFeatureFastBrief = 4

    kFeatureGfttFreak = 5

    kFeatureGfttBrief = 6

    kFeatureBrisk = 7

    kFeatureGfttOrb = 8

    kFeatureKaze = 9

    kFeatureOrbOctree = 10

    kFeatureSuperPointTorch = 11

    kFeatureSurfFreak = 12

    kFeatureGfttDaisy = 13

    kFeatureSurfDaisy = 14

    kFeaturePyDetector = 15

class GPS:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, stamp: float, longitude: float, latitude: float, altitude: float, error: float, bearing: float) -> None: ...

    def stamp(self) -> float: ...

    def longitude(self) -> float: ...

    def latitude(self) -> float: ...

    def altitude(self) -> float: ...

    def error(self) -> float: ...

    def bearing(self) -> float: ...

    def toGeodeticCoords(self) -> GeodeticCoords: ...

class GeodeticCoords:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, latitude: float, longitude: float, altitude: float) -> None: ...

    def latitude(self) -> float: ...

    def longitude(self) -> float: ...

    def altitude(self) -> float: ...

    def setLatitude(self, arg: float, /) -> None: ...

    def setLongitude(self, arg: float, /) -> None: ...

    def setAltitude(self, arg: float, /) -> None: ...

    def toGeocentric_WGS84(self) -> tuple: ...

    def toENU_WGS84(self, arg: GeodeticCoords, /) -> tuple: ...

    def fromGeocentric_WGS84(self, arg: tuple, /) -> None: ...

    def fromENU_WGS84(self, arg0: tuple, arg1: GeodeticCoords, /) -> None: ...

class GlobalDescriptor:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, type: int, data: numpy.array, info: numpy.array) -> None: ...

    def type(self) -> int: ...

    def info(self) -> numpy.array: ...

    def data(self) -> numpy.array: ...

class IMU:
    @overload
    def __init__(self, orientation: list, orientationCovariance: numpy.array, angularVelocity: list, angularVelocityCovariance: numpy.array, linearAcceleration: list, linearAccelerationCovariance: numpy.array) -> None: ...

    @overload
    def __init__(self, angularVelocity: list, angularVelocityCovariance: numpy.array, linearAcceleration: list, linearAccelerationCovariance: numpy.array) -> None: ...

    def orientation(self) -> list: ...

    def orientationCovariance(self) -> numpy.array: ...

    def angularVelocity(self) -> list: ...

    def angularVelocityCovariance(self) -> numpy.array: ...

    def linearAcceleration(self) -> list: ...

    def linearAccelerationCovariance(self) -> numpy.array: ...

    def localTransform(self) -> Transform: ...

    def convertToBaseFrame(self) -> None: ...

    def empty(self) -> bool: ...

class Landmark:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, id: int, size: float, pose: Transform, covariance: numpy.array) -> None: ...

    def id(self) -> int: ...

    def size(self) -> float: ...

    def pose(self) -> Transform: ...

    def covariance(self) -> numpy.array: ...

class LaserScan:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg0: LaserScan, arg1: int, arg2: float, /) -> None: ...

    @overload
    def __init__(self, arg0: numpy.array, arg1: int, arg2: float, arg3: LaserScanFormat, /) -> None: ...

    @overload
    def __init__(self, arg0: LaserScan, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, /) -> None: ...

    @overload
    def __init__(self, arg0: numpy.array, arg1: LaserScanFormat, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, /) -> None: ...

    @staticmethod
    def isScan2d(arg: LaserScanFormat, /) -> bool: ...

    @staticmethod
    def isScanHasNormals(arg: LaserScanFormat, /) -> bool: ...

    @staticmethod
    def isScanHasRGB(arg: LaserScanFormat, /) -> bool: ...

    @staticmethod
    def isScanHasIntensity(arg: LaserScanFormat, /) -> bool: ...

    @staticmethod
    def isScanHasTime(arg: LaserScanFormat, /) -> bool: ...

    @overload
    @staticmethod
    def backwardCompatibility(arg0: numpy.array, arg1: int, arg2: int, /) -> LaserScan: ...

    @overload
    @staticmethod
    def backwardCompatibility(arg0: numpy.array, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, /) -> LaserScan: ...

    @overload
    def clone(self) -> LaserScan: ...

    @overload
    def clone(self) -> LaserScan: ...

    def data(self) -> numpy.array: ...

    def format(self) -> LaserScanFormat: ...

    def formatName(self) -> str: ...

    def channels(self) -> int: ...

    def maxPoints(self) -> int: ...

    def rangeMin(self) -> float: ...

    def rangeMax(self) -> float: ...

    def angleMin(self) -> float: ...

    def angleMax(self) -> float: ...

    def angleIncrement(self) -> float: ...

    def setLocalTransform(self, arg: Transform, /) -> None: ...

    def localTransform(self) -> Transform: ...

    def empty(self) -> bool: ...

    def isEmpty(self) -> bool: ...

    def size(self) -> int: ...

    def dataType(self) -> int: ...

    def is2d(self) -> bool: ...

    def hasNormals(self) -> bool: ...

    def hasRGB(self) -> bool: ...

    def hasIntensity(self) -> bool: ...

    def hasTime(self) -> bool: ...

    def isCompressed(self) -> bool: ...

    def isOrganized(self) -> bool: ...

    def densify(self) -> LaserScan: ...

    def getIntensityOffset(self) -> int: ...

    def getRGBOffset(self) -> int: ...

    def getNormalsOffset(self) -> int: ...

    def getTimeOffset(self) -> int: ...

    def field(self, arg0: int, arg1: int, /) -> float: ...

    def clear(self) -> None: ...

class LaserScanFormat(enum.Enum):
    kUnknown = 0

    kXY = 1

    kXYI = 2

    kXYNormal = 3

    kXYINormal = 4

    kXYZ = 5

    kXYZI = 6

    kXYZRGB = 7

    kXYZNormal = 8

    kXYZINormal = 9

    kXYZRGBNormal = 10

    kXYZIT = 11

class Link:
    def __init__(self, from: int, to: int, type: LinkType, transform: Transform) -> None: ...

    def isValid(self) -> bool: ...

    def from(self) -> int: ...

    def to(self) -> int: ...

    def transform(self) -> Transform: ...

    def type(self) -> LinkType: ...

    def infMatrix(self) -> numpy.array: ...

    def rotVariance(self, arg: bool, /) -> float: ...

    def transVariance(self, arg: bool, /) -> float: ...

    def setFrom(self, arg: int, /) -> None: ...

    def setTo(self, arg: int, /) -> None: ...

    def setTransform(self, arg: Transform, /) -> None: ...

    def setType(self, arg: LinkType, /) -> None: ...

    def setInfMatrix(self, arg: numpy.array, /) -> None: ...

    def userDataRaw(self) -> numpy.array: ...

    def userDataCompressed(self) -> numpy.array: ...

    def uncompressUserData(self) -> None: ...

    def uncompressUserDataConst(self) -> numpy.array: ...

    def merge(self, arg0: Link, arg1: LinkType, /) -> Link: ...

    def inverse(self) -> Link: ...

class LinkType(enum.Enum):
    kNeighbor = 0

    kGlobalClosure = 1

    kLocalSpaceClosure = 2

    kLocalTimeClosure = 3

    kUserClosure = 4

    kVirtualClosure = 5

    kNeighborMerged = 6

    kPosePrior = 7

    kLandmark = 8

    kGravity = 9

    kEnd = 10

    kSelfRefLink = 97

    kAllWithLandmarks = 98

    kAllWithoutLandmarks = 99

    kUndef = 99

class Memory:
    def __init__(self) -> None: ...

    def parseParameters(self, arg: Mapping[str, str], /) -> None: ...

    def getParameters(self) -> dict[str, str]: ...

    @overload
    def update(self, data: SensorData, stats: Statistics) -> bool: ...

    @overload
    def update(self, data: SensorData, pose: Transform, covariance: numpy.array, velocity: Sequence[float], stats: Statistics) -> bool: ...

    def init(self, arg0: str, arg1: bool, arg2: Mapping[str, str], arg3: bool, /) -> bool: ...

    def close(self, arg0: bool, arg1: bool, arg2: str, /) -> None: ...

    def computeLikelihood(self, arg0: Signature, arg1: Sequence[int], /) -> dict[int, float]: ...

    def incrementMapId(self, arg: Mapping[int, int], /) -> int: ...

    def updateAge(self, arg: int, /) -> None: ...

    def forget(self, arg: Set[int], /) -> list[int]: ...

    def reactivateSignatures(self, arg0: Sequence[int], arg1: int, arg2: float, /) -> set[int]: ...

    def cleanup(self) -> int: ...

    def saveStatistics(self, arg0: Statistics, arg1: bool, /) -> None: ...

    def savePreviewImage(self, arg: numpy.array, /) -> None: ...

    def loadPreviewImage(self) -> numpy.array: ...

    def saveOptimizedPoses(self, arg0: Mapping[int, Transform], arg1: Transform, /) -> None: ...

    def loadOptimizedPoses(self, arg: Transform, /) -> dict[int, Transform]: ...

    def save2DMap(self, arg0: numpy.array, arg1: float, arg2: float, arg3: float, /) -> None: ...

    def load2DMap(self, arg0: float, arg1: float, arg2: float, /) -> numpy.array: ...

    def saveOptimizedMesh(self, arg0: numpy.array, arg1: Sequence[Sequence[Sequence[int]]], arg2: Sequence[Sequence[Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]]], arg3: numpy.array, /) -> None: ...

    def loadOptimizedMesh(self, arg0: Sequence[Sequence[Sequence[int]]], arg1: Sequence[Sequence[Annotated[ArrayLike, dict(dtype='float32', shape=(2), order='C')]]], arg2: numpy.array, /) -> numpy.array: ...

    def emptyTrash(self) -> None: ...

    def joinTrashThread(self) -> None: ...

    def addLink(self, arg0: Link, arg1: bool, /) -> bool: ...

    def updateLink(self, arg0: Link, arg1: bool, /) -> None: ...

    def removeAllVirtualLinks(self) -> None: ...

    def removeVirtualLinks(self, arg: int, /) -> None: ...

    def getNeighborsId(self, arg0: int, arg1: int, arg2: int, arg3: bool, arg4: bool, arg5: bool, arg6: bool, arg7: Set[int], arg8: float, /) -> dict[int, int]: ...

    def getNeighborsIdRadius(self, arg0: int, arg1: float, arg2: Mapping[int, Transform], arg3: int, /) -> dict[int, float]: ...

    def deleteLocation(self, arg0: int, arg1: Sequence[int], /) -> None: ...

    def saveLocationData(self, arg: int, /) -> None: ...

    def removeLink(self, arg0: int, arg1: int, /) -> None: ...

    def removeRawData(self, arg0: int, arg1: bool, arg2: bool, arg3: bool, /) -> None: ...

    def getWorkingMem(self) -> dict[int, float]: ...

    def getStMem(self) -> set[int]: ...

    def getMaxStMemSize(self) -> int: ...

    def isBinDataKept(self) -> bool: ...

    def getSimilarityThreshold(self) -> float: ...

    def getWeights(self) -> dict[int, int]: ...

    def getLastSignatureId(self) -> int: ...

    def getLastWorkingSignature(self) -> Signature: ...

    def getNodesObservingLandmark(self, arg0: int, arg1: bool, /) -> dict[int, Link]: ...

    def getSignatureIdByLabel(self, arg0: str, arg1: bool, /) -> int: ...

    def labelSignature(self, arg0: int, arg1: str, /) -> bool: ...

    def getAllLabels(self) -> dict[int, str]: ...

    def getLandmarksIndex(self) -> dict[int, set[int]]: ...

    def allNodesInWM(self) -> bool: ...

    def setUserData(self, arg0: int, arg1: numpy.array, /) -> bool: ...

    def getDatabaseMemoryUsed(self) -> int: ...

    def getDatabaseVersion(self) -> str: ...

    def getDatabaseUrl(self) -> str: ...

    def getDbSavingTime(self) -> float: ...

    def getMapId(self, arg0: int, arg1: bool, /) -> int: ...

    def getOdomPose(self, arg0: int, arg1: bool, /) -> Transform: ...

    def getGroundTruthPose(self, arg0: int, arg1: bool, /) -> Transform: ...

    def getGroundTruths(self) -> dict[int, Transform]: ...

    def getGPS(self, arg0: int, arg1: GPS, arg2: Transform, arg3: bool, arg4: int, /) -> None: ...

    def getNodeInfo(self, arg0: int, arg1: Transform, arg2: int, arg3: int, arg4: str, arg5: float, arg6: Transform, arg7: Sequence[float], arg8: GPS, arg9: Mapping[EnvSensorType, EnvSensor], arg10: bool, /) -> bool: ...

    def getImageCompressed(self, arg: int, /) -> numpy.array: ...

    def getNodeData(self, arg0: int, arg1: bool, arg2: bool, arg3: bool, arg4: bool, /) -> SensorData: ...

    def getNodeCalibration(self, arg0: int, arg1: Sequence[CameraModel], arg2: Sequence[StereoCameraModel], /) -> None: ...

    def getAllSignatureIds(self, arg: bool, /) -> set[int]: ...

    def memoryChanged(self) -> bool: ...

    def isIncremental(self) -> bool: ...

    def isLocalizationDataSaved(self) -> bool: ...

    def getSignature(self, arg: int, /) -> Signature: ...

    def isInSTM(self, arg: int, /) -> bool: ...

    def isInWM(self, arg: int, /) -> bool: ...

    def isInLTM(self, arg: int, /) -> bool: ...

    def isIDsGenerated(self) -> bool: ...

    def getLastGlobalLoopClosureId(self) -> int: ...

    def getFeature2D(self) -> Feature2D: ...

    def isGraphReduced(self) -> bool: ...

    def getOdomMaxInf(self) -> list[float]: ...

    def isOdomGravityUsed(self) -> bool: ...

    def dumpMemoryTree(self, arg: str, /) -> None: ...

    def dumpMemory(self, arg: str, /) -> None: ...

    def dumpSignatures(self, arg0: str, arg1: bool, /) -> None: ...

    def dumpDictionary(self, arg0: str, arg1: str, /) -> None: ...

    def getMemoryUsed(self) -> int: ...

    def generateGraph(self, arg0: str, arg1: Set[int], /) -> None: ...

    def cleanupLocalGrids(self, arg0: Mapping[int, Transform], arg1: numpy.array, arg2: float, arg3: float, arg4: float, arg5: int, arg6: bool, /) -> int: ...

    def getVWDictionary(self) -> VWDictionary: ...

    @overload
    def computeTransform(self, fromS: Signature, toS: Signature, guess: Transform, info: RegistrationInfo, useKnownCorrespondencesIfPossible: bool) -> Transform: ...

    @overload
    def computeTransform(self, fromId: int, toId: int, guess: Transform, info: RegistrationInfo, useKnownCorrespondencesIfPossible: bool) -> Transform: ...

    def computeIcpTransform(self, arg0: Signature, arg1: Signature, arg2: Transform, arg3: RegistrationInfo, /) -> Transform: ...

    def computeIcpTransformMulti(self, arg0: int, arg1: int, arg2: Mapping[int, Transform], arg3: RegistrationInfo, /) -> Transform: ...

class NNStrategy(enum.Enum):
    kNNFlannNaive = 0

    kNNFlannKdTree = 1

    kNNFlannLSH = 2

    kNNBruteForce = 3

    kNNBruteForceGPU = 4

    kNNUndef = 5

class Odometry:
    @overload
    @staticmethod
    def create() -> None: ...

    @overload
    @staticmethod
    def create(arg: OdometryType, /) -> None: ...

    @overload
    def process(self, arg0: SensorData, arg1: OdometryInfo, /) -> Transform: ...

    @overload
    def process(self, arg0: SensorData, arg1: Transform, arg2: OdometryInfo, /) -> Transform: ...

    def reset(self, arg: Transform, /) -> None: ...

    def getType(self) -> OdometryType: ...

    def canProcessRawImages(self) -> bool: ...

    def canProcessAsyncIMU(self) -> bool: ...

    def getPose(self) -> Transform: ...

    def isInfoDataFilled(self) -> bool: ...

    def getVelocityGuess(self) -> Transform: ...

    def previousStamp(self) -> float: ...

    def framesProcessed(self) -> int: ...

    def imagesAlreadyRectified(self) -> bool: ...

class OdometryInfo:
    def __init__(self) -> None: ...

    def statistics(self, arg: Transform, /) -> dict[str, float]: ...

    @property
    def lost(self) -> bool: ...

    @lost.setter
    def lost(self, arg: bool, /) -> None: ...

    @property
    def reg(self) -> RegistrationInfo: ...

    @reg.setter
    def reg(self, arg: RegistrationInfo, /) -> None: ...

    @property
    def features(self) -> int: ...

    @features.setter
    def features(self, arg: int, /) -> None: ...

    @property
    def localMapSize(self) -> int: ...

    @localMapSize.setter
    def localMapSize(self, arg: int, /) -> None: ...

    @property
    def localScanMapSize(self) -> int: ...

    @localScanMapSize.setter
    def localScanMapSize(self, arg: int, /) -> None: ...

    @property
    def localKeyFrames(self) -> int: ...

    @localKeyFrames.setter
    def localKeyFrames(self, arg: int, /) -> None: ...

    @property
    def localBundleOutliers(self) -> int: ...

    @localBundleOutliers.setter
    def localBundleOutliers(self, arg: int, /) -> None: ...

    @property
    def localBundleConstraints(self) -> int: ...

    @localBundleConstraints.setter
    def localBundleConstraints(self, arg: int, /) -> None: ...

    @property
    def localBundleTime(self) -> float: ...

    @localBundleTime.setter
    def localBundleTime(self, arg: float, /) -> None: ...

    @property
    def localBundlePoses(self) -> dict[int, Transform]: ...

    @localBundlePoses.setter
    def localBundlePoses(self, arg: Mapping[int, Transform], /) -> None: ...

    @property
    def localBundleModels(self) -> dict[int, list[CameraModel]]: ...

    @localBundleModels.setter
    def localBundleModels(self, arg: Mapping[int, Sequence[CameraModel]], /) -> None: ...

    @property
    def localBundleAvgInlierDistance(self) -> float: ...

    @localBundleAvgInlierDistance.setter
    def localBundleAvgInlierDistance(self, arg: float, /) -> None: ...

    @property
    def localBundleMaxKeyFramesForInlier(self) -> int: ...

    @localBundleMaxKeyFramesForInlier.setter
    def localBundleMaxKeyFramesForInlier(self, arg: int, /) -> None: ...

    @property
    def localBundleOutliersPerCam(self) -> list[int]: ...

    @localBundleOutliersPerCam.setter
    def localBundleOutliersPerCam(self, arg: Sequence[int], /) -> None: ...

    @property
    def keyFrameAdded(self) -> bool: ...

    @keyFrameAdded.setter
    def keyFrameAdded(self, arg: bool, /) -> None: ...

    @property
    def timeDeskewing(self) -> float: ...

    @timeDeskewing.setter
    def timeDeskewing(self, arg: float, /) -> None: ...

    @property
    def timeEstimation(self) -> float: ...

    @timeEstimation.setter
    def timeEstimation(self, arg: float, /) -> None: ...

    @property
    def timeParticleFiltering(self) -> float: ...

    @timeParticleFiltering.setter
    def timeParticleFiltering(self, arg: float, /) -> None: ...

    @property
    def stamp(self) -> float: ...

    @stamp.setter
    def stamp(self, arg: float, /) -> None: ...

    @property
    def interval(self) -> float: ...

    @interval.setter
    def interval(self, arg: float, /) -> None: ...

    @property
    def transform(self) -> Transform: ...

    @transform.setter
    def transform(self, arg: Transform, /) -> None: ...

    @property
    def transformFiltered(self) -> Transform: ...

    @transformFiltered.setter
    def transformFiltered(self, arg: Transform, /) -> None: ...

    @property
    def transformGroundTruth(self) -> Transform: ...

    @transformGroundTruth.setter
    def transformGroundTruth(self, arg: Transform, /) -> None: ...

    @property
    def guessVelocity(self) -> Transform: ...

    @guessVelocity.setter
    def guessVelocity(self, arg: Transform, /) -> None: ...

    @property
    def guess(self) -> Transform: ...

    @guess.setter
    def guess(self, arg: Transform, /) -> None: ...

    @property
    def distanceTravelled(self) -> float: ...

    @distanceTravelled.setter
    def distanceTravelled(self, arg: float, /) -> None: ...

    @property
    def memoryUsage(self) -> int: ...

    @memoryUsage.setter
    def memoryUsage(self, arg: int, /) -> None: ...

    @property
    def gravityRollError(self) -> float: ...

    @gravityRollError.setter
    def gravityRollError(self, arg: float, /) -> None: ...

    @property
    def gravityPitchError(self) -> float: ...

    @gravityPitchError.setter
    def gravityPitchError(self, arg: float, /) -> None: ...

    @property
    def type(self) -> int: ...

    @type.setter
    def type(self, arg: int, /) -> None: ...

    @property
    def localMap(self) -> dict[int, tuple]: ...

    @localMap.setter
    def localMap(self, arg: Mapping[int, tuple], /) -> None: ...

    @property
    def localScanMap(self) -> LaserScan: ...

    @localScanMap.setter
    def localScanMap(self, arg: LaserScan, /) -> None: ...

    @property
    def refCorners(self) -> list[tuple]: ...

    @refCorners.setter
    def refCorners(self, arg: Sequence[tuple], /) -> None: ...

    @property
    def newCorners(self) -> list[tuple]: ...

    @newCorners.setter
    def newCorners(self, arg: Sequence[tuple], /) -> None: ...

    @property
    def cornerInliers(self) -> list[int]: ...

    @cornerInliers.setter
    def cornerInliers(self, arg: Sequence[int], /) -> None: ...

class OdometryType(enum.Enum):
    kTypeUndef = -1

    kTypeF2M = 0

    kTypeF2F = 1

    kTypeFovis = 2

    kTypeViso2 = 3

    kTypeDVO = 4

    kTypeORBSLAM = 5

    kTypeOkvis = 6

    kTypeLOAM = 7

    kTypeMSCKF = 8

    kTypeVINSFusion = 9

    kTypeOpenVINS = 10

    kTypeFLOAM = 11

    kTypeOpen3D = 12

class ProgressState:
    def __init__(self) -> None: ...

    def setCanceled(self, arg: bool, /) -> None: ...

    def isCanceled(self) -> bool: ...

class RegistrationInfo:
    def __init__(self) -> None: ...

    def copyWithoutData(self) -> RegistrationInfo: ...

    @property
    def covariance(self) -> numpy.array: ...

    @covariance.setter
    def covariance(self, arg: numpy.array, /) -> None: ...

    @property
    def rejectedMsg(self) -> str: ...

    @rejectedMsg.setter
    def rejectedMsg(self, arg: str, /) -> None: ...

    @property
    def totalTime(self) -> float: ...

    @totalTime.setter
    def totalTime(self, arg: float, /) -> None: ...

    @property
    def inliers(self) -> int: ...

    @inliers.setter
    def inliers(self, arg: int, /) -> None: ...

    @property
    def inliersRatio(self) -> float: ...

    @inliersRatio.setter
    def inliersRatio(self, arg: float, /) -> None: ...

    @property
    def inliersMeanDistance(self) -> float: ...

    @inliersMeanDistance.setter
    def inliersMeanDistance(self, arg: float, /) -> None: ...

    @property
    def inliersDistribution(self) -> float: ...

    @inliersDistribution.setter
    def inliersDistribution(self, arg: float, /) -> None: ...

    @property
    def inliersIDs(self) -> list[int]: ...

    @inliersIDs.setter
    def inliersIDs(self, arg: Sequence[int], /) -> None: ...

    @property
    def matches(self) -> int: ...

    @matches.setter
    def matches(self, arg: int, /) -> None: ...

    @property
    def matchesIDs(self) -> list[int]: ...

    @matchesIDs.setter
    def matchesIDs(self, arg: Sequence[int], /) -> None: ...

    @property
    def projectedIDs(self) -> list[int]: ...

    @projectedIDs.setter
    def projectedIDs(self, arg: Sequence[int], /) -> None: ...

    @property
    def inliersPerCam(self) -> list[int]: ...

    @inliersPerCam.setter
    def inliersPerCam(self, arg: Sequence[int], /) -> None: ...

    @property
    def matchesPerCam(self) -> list[int]: ...

    @matchesPerCam.setter
    def matchesPerCam(self, arg: Sequence[int], /) -> None: ...

    @property
    def icpInliersRatio(self) -> float: ...

    @icpInliersRatio.setter
    def icpInliersRatio(self, arg: float, /) -> None: ...

    @property
    def icpTranslation(self) -> float: ...

    @icpTranslation.setter
    def icpTranslation(self, arg: float, /) -> None: ...

    @property
    def icpRotation(self) -> float: ...

    @icpRotation.setter
    def icpRotation(self, arg: float, /) -> None: ...

    @property
    def icpStructuralComplexity(self) -> float: ...

    @icpStructuralComplexity.setter
    def icpStructuralComplexity(self, arg: float, /) -> None: ...

    @property
    def icpStructuralDistribution(self) -> float: ...

    @icpStructuralDistribution.setter
    def icpStructuralDistribution(self, arg: float, /) -> None: ...

    @property
    def icpCorrespondences(self) -> int: ...

    @icpCorrespondences.setter
    def icpCorrespondences(self, arg: int, /) -> None: ...

    @property
    def icpRMS(self) -> float: ...

    @icpRMS.setter
    def icpRMS(self, arg: float, /) -> None: ...

class Rtabmap:
    def __init__(self) -> None: ...

    @overload
    def process(self, data: SensorData, odomPose: Transform, odomCovariance: numpy.array, odomVelocity: Sequence[float], externalStats: Mapping[str, float]) -> bool: ...

    @overload
    def process(self, data: SensorData, odomPose: Transform, odomLinearVariance: float, odomAngularVariance: float, odomVelocity: Sequence[float], externalStats: Mapping[str, float]) -> bool: ...

    @overload
    def process(self, image: numpy.array, id: int, externalStats: Mapping[str, float]) -> bool: ...

    @overload
    def init(self, parameters: Mapping[str, str], databasePath: str, loadDatabaseParameters: bool) -> None: ...

    @overload
    def init(self, configFile: str, databasePath: str, loadDatabaseParameters: bool) -> None: ...

    def close(self, databaseSaved: bool = True, ouputDatabasePath: str = '') -> None: ...

    def getWorkingDir(self) -> str: ...

    def isRGBDMode(self) -> bool: ...

    def getLoopClosureId(self) -> int: ...

    def getLoopClosureValue(self) -> float: ...

    def getHighestHypothesisId(self) -> int: ...

    def getHighestHypothesisValue(self) -> float: ...

    def getLastLocationId(self) -> int: ...

    def getWM(self) -> list[int]: ...

    def getSTM(self) -> set[int]: ...

    def getWMSize(self) -> int: ...

    def getSTMSize(self) -> int: ...

    def getWeights(self) -> dict[int, int]: ...

    def getTotalMemSize(self) -> int: ...

    def getLastProcessTime(self) -> float: ...

    def isInSTM(self, locationId: int) -> bool: ...

    def isIDsGenerated(self) -> bool: ...

    def getStatistics(self) -> Statistics: ...

    def getLocalOptimizedPoses(self) -> dict[int, Transform]: ...

    def getPose(self, locationId: int) -> Transform: ...

    def getMapCorrection(self) -> Transform: ...

    def getMemory(self) -> Memory: ...

    def getGoalReachedRadius(self) -> float: ...

    def getLocalRadius(self) -> float: ...

    def getLastLocalizationPose(self) -> Transform: ...

    def getTimeThreshold(self) -> float: ...

    def setTimeThreshold(self, maxTimeAllowed: float) -> None: ...

    def getMemoryThreshold(self) -> int: ...

    def setMemoryThreshold(self, maxMemoryAllowed: int) -> None: ...

    def setInitialPose(self, initialPose: Transform) -> None: ...

    def triggerNewMap(self) -> int: ...

    def labelLocation(self, id: int, label: str) -> bool: ...

    def setUserData(self, id: int, data: numpy.array) -> bool: ...

    def generateDOTGraph(self, path: str, id: int = 0, margin: int = 5) -> None: ...

    def exportPoses(self, path: str, optimized: bool, globals: bool, format: int) -> None: ...

    def resetMemory(self) -> None: ...

    def dumpPrediction(self) -> None: ...

    def dumpData(self) -> None: ...

    def parseParameters(self, parameters: Mapping[str, str]) -> None: ...

    def getParameters(self) -> dict[str, str]: ...

    def setWorkingDirectory(self, path: str) -> None: ...

    def rejectLastLoopClosure(self) -> None: ...

    def deleteLastLocation(self) -> None: ...

    def getSignatureCopy(self, id: int, images: bool, scan: bool, userData: bool, occupancyGrid: bool, withWords: bool, withGlobalDescriptors: bool) -> Signature: ...

    @overload
    def getNodesInRadius(self, pose: Transform, radius: float, k: int, distsSqr: Mapping[int, float]) -> dict[int, Transform]: ...

    @overload
    def getNodesInRadius(self, nodeId: int, radius: float, k: int, distsSqr: Mapping[int, float]) -> dict[int, Transform]: ...

    def detectMoreLoopClosures(self, clusterRadiusMax: float = 0.5, clusterAngle: float = 0.5235987755982988, iterations: int = 1, intraSession: bool = True, interSession: bool = True, state: ProgressState = 0, clusterRadiusMin: float = 0.0) -> int: ...

    def globalBundleAdjustment(self, optimizerType: int = 1, rematchFeatures: bool = True, iterations: int = 0, pixelVariance: float = 0.0) -> bool: ...

    def cleanupLocalGrids(self, mapPoses: Mapping[int, Transform], map: numpy.array, xMin: float, yMin: float, cellSize: float, cropRadius: int = 1, filterScans: bool = False) -> int: ...

    def refineLinks(self) -> int: ...

    def addLink(self, link: Link) -> bool: ...

    def getInformation(self, covariance: numpy.array) -> numpy.array: ...

    def addNodesToRepublish(self, ids: Sequence[int]) -> None: ...

    def getPathStatus(self) -> int: ...

    def clearPath(self, status: int) -> None: ...

    @overload
    def computePath(self, targetNode: int, globals: bool) -> bool: ...

    @overload
    def computePath(self, targetPose: Transform, tolerance: float) -> bool: ...

    def getPath(self) -> list[tuple[int, Transform]]: ...

    def getPathNextPoses(self) -> list[tuple[int, Transform]]: ...

    def getPathNextNodes(self) -> list[int]: ...

    def getPathCurrentGoalId(self) -> int: ...

    def getPathCurrentIndex(self) -> int: ...

    def getPathCurrentGoalIndex(self) -> int: ...

    def getPathTransformToGoal(self) -> Transform: ...

    def getForwardWMPoses(self, fromId: int, maxNearestNeighbors: int, radius: float, maxDiffID: int) -> dict[int, Transform]: ...

    def getPaths(self, poses: Mapping[int, Transform], target: Transform, maxGraphDepth: int = 0) -> dict[int, dict[int, Transform]]: ...

    def adjustLikelihood(self, likelihood: Mapping[int, float]) -> None: ...

class SensorData:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, arg0: numpy.array, arg1: int, arg2: float, /) -> None: ...

    @overload
    def __init__(self, arg0: numpy.array, arg1: CameraModel, arg2: int, arg3: float, /) -> None: ...

    @overload
    def __init__(self, arg0: numpy.array, arg1: numpy.array, arg2: CameraModel, arg3: int, arg4: float, /) -> None: ...

    @overload
    def __init__(self, arg0: LaserScan, arg1: numpy.array, arg2: numpy.array, arg3: CameraModel, arg4: int, arg5: float, /) -> None: ...

    @overload
    def __init__(self, arg0: LaserScan, arg1: numpy.array, arg2: numpy.array, arg3: numpy.array, arg4: CameraModel, arg5: int, arg6: float, /) -> None: ...

    @overload
    def __init__(self, arg0: numpy.array, arg1: numpy.array, arg2: Sequence[CameraModel], arg3: int, arg4: float, /) -> None: ...

    @overload
    def __init__(self, arg0: numpy.array, arg1: numpy.array, arg2: numpy.array, arg3: Sequence[CameraModel], arg4: int, arg5: float, /) -> None: ...

    @overload
    def __init__(self, arg0: LaserScan, arg1: numpy.array, arg2: numpy.array, arg3: Sequence[CameraModel], arg4: int, arg5: float, /) -> None: ...

    @overload
    def __init__(self, arg0: LaserScan, arg1: numpy.array, arg2: numpy.array, arg3: numpy.array, arg4: Sequence[CameraModel], arg5: int, arg6: float, /) -> None: ...

    @overload
    def __init__(self, arg0: numpy.array, arg1: numpy.array, arg2: StereoCameraModel, arg3: int, arg4: float, /) -> None: ...

    @overload
    def __init__(self, arg0: LaserScan, arg1: numpy.array, arg2: numpy.array, arg3: StereoCameraModel, arg4: int, arg5: float, /) -> None: ...

    @overload
    def __init__(self, arg0: numpy.array, arg1: numpy.array, arg2: Sequence[StereoCameraModel], arg3: int, arg4: float, /) -> None: ...

    @overload
    def __init__(self, arg0: LaserScan, arg1: numpy.array, arg2: numpy.array, arg3: Sequence[StereoCameraModel], arg4: int, arg5: float, /) -> None: ...

    @overload
    def __init__(self, arg0: IMU, arg1: int, arg2: float, /) -> None: ...

    def isValid(self) -> bool: ...

    def id(self) -> int: ...

    def setId(self, arg: int, /) -> None: ...

    def stamp(self) -> float: ...

    def setStamp(self, arg: float, /) -> None: ...

    def imageCompressed(self) -> numpy.array: ...

    def depthOrRightCompressed(self) -> numpy.array: ...

    def depthConfidenceCompressed(self) -> numpy.array: ...

    def laserScanCompressed(self) -> LaserScan: ...

    def imageRaw(self) -> numpy.array: ...

    def depthOrRightRaw(self) -> numpy.array: ...

    def depthConfidenceRaw(self) -> numpy.array: ...

    def laserScanRaw(self) -> LaserScan: ...

    @overload
    def setRGBDImage(self, arg0: numpy.array, arg1: numpy.array, arg2: CameraModel, arg3: bool, /) -> None: ...

    @overload
    def setRGBDImage(self, arg0: numpy.array, arg1: numpy.array, arg2: CameraModel, arg3: bool, /) -> None: ...

    @overload
    def setRGBDImage(self, arg0: numpy.array, arg1: numpy.array, arg2: numpy.array, arg3: CameraModel, arg4: bool, /) -> None: ...

    @overload
    def setRGBDImage(self, arg0: numpy.array, arg1: numpy.array, arg2: Sequence[CameraModel], arg3: bool, /) -> None: ...

    @overload
    def setStereoImage(self, arg0: numpy.array, arg1: numpy.array, arg2: StereoCameraModel, arg3: bool, /) -> None: ...

    @overload
    def setStereoImage(self, arg0: numpy.array, arg1: numpy.array, arg2: Sequence[StereoCameraModel], arg3: bool, /) -> None: ...

    def setLaserScan(self, arg0: LaserScan, arg1: bool, /) -> None: ...

    def setCameraModel(self, arg: CameraModel, /) -> None: ...

    def setCameraModels(self, arg: Sequence[CameraModel], /) -> None: ...

    def setStereoCameraModel(self, arg: StereoCameraModel, /) -> None: ...

    def setStereoCameraModels(self, arg: Sequence[StereoCameraModel], /) -> None: ...

    def depthRaw(self) -> numpy.array: ...

    def rightRaw(self) -> numpy.array: ...

    def uncompressData(self) -> None: ...

    def cameraModels(self) -> list[CameraModel]: ...

    def stereoCameraModels(self) -> list[StereoCameraModel]: ...

    def setUserData(self, arg0: numpy.array, arg1: bool, /) -> None: ...

    def userDataRaw(self) -> numpy.array: ...

    def userDataCompressed(self) -> numpy.array: ...

    def setOccupancyGrid(self, arg0: numpy.array, arg1: numpy.array, arg2: numpy.array, arg3: float, arg4: tuple, /) -> None: ...

    def clearOccupancyGridRaw(self) -> None: ...

    def gridGroundCellsRaw(self) -> numpy.array: ...

    def gridGroundCellsCompressed(self) -> numpy.array: ...

    def gridObstacleCellsRaw(self) -> numpy.array: ...

    def gridObstacleCellsCompressed(self) -> numpy.array: ...

    def gridEmptyCellsRaw(self) -> numpy.array: ...

    def gridEmptyCellsCompressed(self) -> numpy.array: ...

    def gridCellSize(self) -> float: ...

    def gridViewPoint(self) -> tuple: ...

    def setFeatures(self, arg0: Sequence["cv::KeyPoint"], arg1: Sequence[tuple], arg2: numpy.array, /) -> None: ...

    def keypoints(self) -> list["cv::KeyPoint"]: ...

    def keypoints3D(self) -> list[tuple]: ...

    def descriptors(self) -> numpy.array: ...

    def addGlobalDescriptor(self, arg: GlobalDescriptor, /) -> None: ...

    def setGlobalDescriptors(self, arg: Sequence[GlobalDescriptor], /) -> None: ...

    def clearGlobalDescriptors(self) -> None: ...

    def globalDescriptors(self) -> list[GlobalDescriptor]: ...

    def setGroundTruth(self, arg: Transform, /) -> None: ...

    def groundTruth(self) -> Transform: ...

    def setGlobalPose(self, arg0: Transform, arg1: numpy.array, /) -> None: ...

    def globalPose(self) -> Transform: ...

    def globalPoseCovariance(self) -> numpy.array: ...

    def setGPS(self, arg: GPS, /) -> None: ...

    def gps(self) -> GPS: ...

    def setIMU(self, arg: IMU, /) -> None: ...

    def imu(self) -> IMU: ...

    def setEnvSensors(self, arg: Mapping[EnvSensorType, EnvSensor], /) -> None: ...

    def addEnvSensor(self, arg: EnvSensor, /) -> None: ...

    @overload
    def envSensors(self) -> dict[EnvSensorType, EnvSensor]: ...

    @overload
    def envSensors(self) -> dict[EnvSensorType, EnvSensor]: ...

    def setLandmarks(self, arg: Mapping[int, Landmark], /) -> None: ...

    def landmarks(self) -> dict[int, Landmark]: ...

    def getMemoryUsed(self) -> int: ...

    def clearCompressedData(self, arg0: bool, arg1: bool, arg2: bool, /) -> None: ...

    def clearRawData(self, arg0: bool, arg1: bool, arg2: bool, /) -> None: ...

    def isPointVisibleFromCameras(self, arg: tuple, /) -> bool: ...

class Signature:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, id: int) -> None: ...

    def compareTo(self, arg: Signature, /) -> float: ...

    def isBadSignature(self) -> bool: ...

    @overload
    def id(self) -> int: ...

    @overload
    def id(self) -> int: ...

    def mapId(self) -> int: ...

    def setWeight(self, arg: int, /) -> None: ...

    def getWeight(self) -> int: ...

    def setLabel(self, arg: str, /) -> None: ...

    def getLabel(self) -> str: ...

    def getStamp(self) -> float: ...

    @overload
    def addLinks(self, arg: Sequence[Link], /) -> None: ...

    @overload
    def addLinks(self, arg: Mapping[int, Link], /) -> None: ...

    def addLink(self, arg: Link, /) -> None: ...

    def hasLink(self, arg0: int, arg1: LinkType, /) -> bool: ...

    def changeLinkIds(self, arg0: int, arg1: int, /) -> None: ...

    def removeLinks(self, arg: bool, /) -> None: ...

    def removeLink(self, arg: int, /) -> None: ...

    def removeVirtualLinks(self) -> None: ...

    def addLandmark(self, arg: Link, /) -> None: ...

    def getLandmarks(self) -> dict[int, Link]: ...

    def removeLandmarks(self) -> None: ...

    def removeLandmark(self, arg: int, /) -> None: ...

    def setSaved(self, arg: bool, /) -> None: ...

    def setModified(self, arg: bool, /) -> None: ...

    def isSaved(self) -> bool: ...

    def isModified(self) -> bool: ...

    def isLinksModified(self) -> bool: ...

    def changeWordsRef(self, arg0: int, arg1: int, /) -> None: ...

    def isEnabled(self) -> bool: ...

    def setEnabled(self, arg: bool, /) -> None: ...

    def getWordsKpts(self) -> list["cv::KeyPoint"]: ...

    def getInvalidWordsCount(self) -> int: ...

    def getWordsChanged(self) -> dict[int, int]: ...

    def getWordsDescriptors(self) -> numpy.array: ...

    def setWordsDescriptors(self, arg: numpy.array, /) -> None: ...

    def setPose(self, arg: Transform, /) -> None: ...

    def setGroundTruthPose(self, arg: Transform, /) -> None: ...

    def setVelocity(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, /) -> None: ...

    def getWords3(self) -> list[tuple]: ...

    def getPose(self) -> Transform: ...

    def getPoseCovariance(self) -> numpy.array: ...

    def getGroundTruthPose(self) -> Transform: ...

    def getVelocity(self) -> list[float]: ...

    def sensorData(self) -> SensorData: ...

    def getMemoryUsed(self, arg: bool, /) -> int: ...

class Statistics:
    def __init__(self) -> None: ...

    @staticmethod
    def kLoopId() -> str: ...

    @staticmethod
    def kLoopRejectedHypothesis() -> str: ...

    @staticmethod
    def kLoopAccepted_hypothesis_id() -> str: ...

    @staticmethod
    def kLoopSuppressed_hypothesis_id() -> str: ...

    @staticmethod
    def kLoopHighest_hypothesis_id() -> str: ...

    @staticmethod
    def kLoopHighest_hypothesis_value() -> str: ...

    @staticmethod
    def kLoopVp_hypothesis() -> str: ...

    @staticmethod
    def kLoopReactivate_id() -> str: ...

    @staticmethod
    def kLoopHypothesis_ratio() -> str: ...

    @staticmethod
    def kLoopHypothesis_reactivated() -> str: ...

    @staticmethod
    def kLoopMap_id() -> str: ...

    @staticmethod
    def kLoopVisual_words() -> str: ...

    @staticmethod
    def kLoopVisual_inliers() -> str: ...

    @staticmethod
    def kLoopVisual_inliers_ratio() -> str: ...

    @staticmethod
    def kLoopVisual_matches() -> str: ...

    @staticmethod
    def kLoopDistance_since_last_loc() -> str: ...

    @staticmethod
    def kLoopLast_id() -> str: ...

    @staticmethod
    def kLoopOptimization_max_error() -> str: ...

    @staticmethod
    def kLoopOptimization_max_error_ratio() -> str: ...

    @staticmethod
    def kLoopOptimization_max_ang_error() -> str: ...

    @staticmethod
    def kLoopOptimization_max_ang_error_ratio() -> str: ...

    @staticmethod
    def kLoopOptimization_error() -> str: ...

    @staticmethod
    def kLoopOptimization_iterations() -> str: ...

    @staticmethod
    def kLoopLinear_variance() -> str: ...

    @staticmethod
    def kLoopAngular_variance() -> str: ...

    @staticmethod
    def kLoopLandmark_detected() -> str: ...

    @staticmethod
    def kLoopLandmark_detected_node_ref() -> str: ...

    @staticmethod
    def kLoopVisual_inliers_mean_dist() -> str: ...

    @staticmethod
    def kLoopVisual_inliers_distribution() -> str: ...

    @staticmethod
    def kLoopProximity_links_cleared() -> str: ...

    @staticmethod
    def kLoopOdom_correction_norm() -> str: ...

    @staticmethod
    def kLoopOdom_correction_angle() -> str: ...

    @staticmethod
    def kLoopOdom_correction_x() -> str: ...

    @staticmethod
    def kLoopOdom_correction_y() -> str: ...

    @staticmethod
    def kLoopOdom_correction_z() -> str: ...

    @staticmethod
    def kLoopOdom_correction_roll() -> str: ...

    @staticmethod
    def kLoopOdom_correction_pitch() -> str: ...

    @staticmethod
    def kLoopOdom_correction_yaw() -> str: ...

    @staticmethod
    def kLoopMapToOdom_norm() -> str: ...

    @staticmethod
    def kLoopMapToOdom_angle() -> str: ...

    @staticmethod
    def kLoopMapToOdom_x() -> str: ...

    @staticmethod
    def kLoopMapToOdom_y() -> str: ...

    @staticmethod
    def kLoopMapToOdom_z() -> str: ...

    @staticmethod
    def kLoopMapToOdom_roll() -> str: ...

    @staticmethod
    def kLoopMapToOdom_yaw() -> str: ...

    @staticmethod
    def kLoopMapToOdom_pitch() -> str: ...

    @staticmethod
    def kLoopMapToBase_x() -> str: ...

    @staticmethod
    def kLoopMapToBase_y() -> str: ...

    @staticmethod
    def kLoopMapToBase_z() -> str: ...

    @staticmethod
    def kLoopMapToBase_roll() -> str: ...

    @staticmethod
    def kLoopMapToBase_pitch() -> str: ...

    @staticmethod
    def kLoopMapToBase_yaw() -> str: ...

    @staticmethod
    def kLoopMapToBase_lin_std() -> str: ...

    @staticmethod
    def kLoopMapToBase_lin_var() -> str: ...

    @staticmethod
    def kProximityTime_detections() -> str: ...

    @staticmethod
    def kProximitySpace_last_detection_id() -> str: ...

    @staticmethod
    def kProximitySpace_paths() -> str: ...

    @staticmethod
    def kProximitySpace_visual_paths_checked() -> str: ...

    @staticmethod
    def kProximitySpace_scan_paths_checked() -> str: ...

    @staticmethod
    def kProximitySpace_detections_added_visually() -> str: ...

    @staticmethod
    def kProximitySpace_detections_added_icp_multi() -> str: ...

    @staticmethod
    def kProximitySpace_detections_added_icp_global() -> str: ...

    @staticmethod
    def kNeighborLinkRefiningAccepted() -> str: ...

    @staticmethod
    def kNeighborLinkRefiningInliers() -> str: ...

    @staticmethod
    def kNeighborLinkRefiningICP_inliers_ratio() -> str: ...

    @staticmethod
    def kNeighborLinkRefiningICP_rotation() -> str: ...

    @staticmethod
    def kNeighborLinkRefiningICP_translation() -> str: ...

    @staticmethod
    def kNeighborLinkRefiningICP_complexity() -> str: ...

    @staticmethod
    def kNeighborLinkRefiningVariance() -> str: ...

    @staticmethod
    def kNeighborLinkRefiningPts() -> str: ...

    @staticmethod
    def kMemoryWorking_memory_size() -> str: ...

    @staticmethod
    def kMemoryShort_time_memory_size() -> str: ...

    @staticmethod
    def kMemoryDatabase_memory_used() -> str: ...

    @staticmethod
    def kMemorySignatures_removed() -> str: ...

    @staticmethod
    def kMemoryImmunized_globally() -> str: ...

    @staticmethod
    def kMemoryImmunized_locally() -> str: ...

    @staticmethod
    def kMemoryImmunized_locally_max() -> str: ...

    @staticmethod
    def kMemorySignatures_retrieved() -> str: ...

    @staticmethod
    def kMemoryImages_buffered() -> str: ...

    @staticmethod
    def kMemoryRehearsal_sim() -> str: ...

    @staticmethod
    def kMemoryRehearsal_id() -> str: ...

    @staticmethod
    def kMemoryRehearsal_merged() -> str: ...

    @staticmethod
    def kMemoryLocal_graph_size() -> str: ...

    @staticmethod
    def kMemoryOdom_cache_poses() -> str: ...

    @staticmethod
    def kMemoryOdom_cache_links() -> str: ...

    @staticmethod
    def kMemorySmall_movement() -> str: ...

    @staticmethod
    def kMemoryFast_movement() -> str: ...

    @staticmethod
    def kMemoryNew_landmark() -> str: ...

    @staticmethod
    def kMemoryOdometry_variance_ang() -> str: ...

    @staticmethod
    def kMemoryOdometry_variance_lin() -> str: ...

    @staticmethod
    def kMemoryDistance_travelled() -> str: ...

    @staticmethod
    def kMemoryRAM_usage() -> str: ...

    @staticmethod
    def kMemoryRAM_estimated() -> str: ...

    @staticmethod
    def kMemoryTriangulated_points() -> str: ...

    @staticmethod
    def kMemoryClosest_node_distance() -> str: ...

    @staticmethod
    def kMemoryClosest_node_angle() -> str: ...

    @staticmethod
    def kTimingMemory_update() -> str: ...

    @staticmethod
    def kTimingNeighbor_link_refining() -> str: ...

    @staticmethod
    def kTimingProximity_by_time() -> str: ...

    @staticmethod
    def kTimingProximity_by_space_search() -> str: ...

    @staticmethod
    def kTimingProximity_by_space_visual() -> str: ...

    @staticmethod
    def kTimingProximity_by_space() -> str: ...

    @staticmethod
    def kTimingCleaning_neighbors() -> str: ...

    @staticmethod
    def kTimingReactivation() -> str: ...

    @staticmethod
    def kTimingAdd_loop_closure_link() -> str: ...

    @staticmethod
    def kTimingMap_optimization() -> str: ...

    @staticmethod
    def kTimingLikelihood_computation() -> str: ...

    @staticmethod
    def kTimingPosterior_computation() -> str: ...

    @staticmethod
    def kTimingHypotheses_creation() -> str: ...

    @staticmethod
    def kTimingHypotheses_validation() -> str: ...

    @staticmethod
    def kTimingStatistics_creation() -> str: ...

    @staticmethod
    def kTimingMemory_cleanup() -> str: ...

    @staticmethod
    def kTimingTotal() -> str: ...

    @staticmethod
    def kTimingForgetting() -> str: ...

    @staticmethod
    def kTimingJoining_trash() -> str: ...

    @staticmethod
    def kTimingEmptying_trash() -> str: ...

    @staticmethod
    def kTimingFinalizing_statistics() -> str: ...

    @staticmethod
    def kTimingRAM_estimation() -> str: ...

    @staticmethod
    def kTimingMemPre_update() -> str: ...

    @staticmethod
    def kTimingMemSignature_creation() -> str: ...

    @staticmethod
    def kTimingMemRehearsal() -> str: ...

    @staticmethod
    def kTimingMemKeypoints_detection() -> str: ...

    @staticmethod
    def kTimingMemSubpixel() -> str: ...

    @staticmethod
    def kTimingMemStereo_correspondences() -> str: ...

    @staticmethod
    def kTimingMemDescriptors_extraction() -> str: ...

    @staticmethod
    def kTimingMemRectification() -> str: ...

    @staticmethod
    def kTimingMemKeypoints_3D() -> str: ...

    @staticmethod
    def kTimingMemKeypoints_3D_motion() -> str: ...

    @staticmethod
    def kTimingMemJoining_dictionary_update() -> str: ...

    @staticmethod
    def kTimingMemAdd_new_words() -> str: ...

    @staticmethod
    def kTimingMemCompressing_data() -> str: ...

    @staticmethod
    def kTimingMemPost_decimation() -> str: ...

    @staticmethod
    def kTimingMemScan_filtering() -> str: ...

    @staticmethod
    def kTimingMemOccupancy_grid() -> str: ...

    @staticmethod
    def kTimingMemMarkers_detection() -> str: ...

    @staticmethod
    def kKeypointDictionary_size() -> str: ...

    @staticmethod
    def kKeypointCurrent_frame() -> str: ...

    @staticmethod
    def kKeypointIndexed_words() -> str: ...

    @staticmethod
    def kKeypointIndex_memory_usage() -> str: ...

    @staticmethod
    def kGtTranslational_rmse() -> str: ...

    @staticmethod
    def kGtTranslational_mean() -> str: ...

    @staticmethod
    def kGtTranslational_median() -> str: ...

    @staticmethod
    def kGtTranslational_std() -> str: ...

    @staticmethod
    def kGtTranslational_min() -> str: ...

    @staticmethod
    def kGtTranslational_max() -> str: ...

    @staticmethod
    def kGtRotational_rmse() -> str: ...

    @staticmethod
    def kGtRotational_mean() -> str: ...

    @staticmethod
    def kGtRotational_median() -> str: ...

    @staticmethod
    def kGtRotational_std() -> str: ...

    @staticmethod
    def kGtRotational_min() -> str: ...

    @staticmethod
    def kGtRotational_max() -> str: ...

    @staticmethod
    def kGtLocalization_linear_error() -> str: ...

    @staticmethod
    def kGtLocalization_angular_error() -> str: ...

    @staticmethod
    def defaultData() -> dict[str, float]: ...

    @staticmethod
    def serializeData(arg: Mapping[str, float], /) -> str: ...

    @staticmethod
    def deserializeData(arg: str, /) -> dict[str, float]: ...

    def addStatistic(self, arg0: str, arg1: float, /) -> None: ...

    def setExtended(self, arg: bool, /) -> None: ...

    def setRefImageId(self, arg: int, /) -> None: ...

    def setRefImageMapId(self, arg: int, /) -> None: ...

    def setLoopClosureId(self, arg: int, /) -> None: ...

    def setLoopClosureMapId(self, arg: int, /) -> None: ...

    def setProximityDetectionId(self, arg: int, /) -> None: ...

    def setProximityDetectionMapId(self, arg: int, /) -> None: ...

    def setStamp(self, arg: float, /) -> None: ...

    def addSignatureData(self, arg: Signature, /) -> None: ...

    def setSignaturesData(self, arg: Mapping[int, Signature], /) -> None: ...

    def setPoses(self, arg: Mapping[int, Transform], /) -> None: ...

    def setMapCorrection(self, arg: Transform, /) -> None: ...

    def setLoopClosureTransform(self, arg: Transform, /) -> None: ...

    def setLocalizationCovariance(self, arg: numpy.array, /) -> None: ...

    def setLabels(self, arg: Mapping[int, str], /) -> None: ...

    def setWeights(self, arg: Mapping[int, int], /) -> None: ...

    def setPosterior(self, arg: Mapping[int, float], /) -> None: ...

    def setLikelihood(self, arg: Mapping[int, float], /) -> None: ...

    def setRawLikelihood(self, arg: Mapping[int, float], /) -> None: ...

    def setLocalPath(self, arg: Sequence[int], /) -> None: ...

    def setCurrentGoalId(self, arg: int, /) -> None: ...

    def setReducedIds(self, arg: Mapping[int, int], /) -> None: ...

    def setWmState(self, arg: Sequence[int], /) -> None: ...

    def setOdomCachePoses(self, arg: Mapping[int, Transform], /) -> None: ...

    def extended(self) -> bool: ...

    def refImageId(self) -> int: ...

    def refImageMapId(self) -> int: ...

    def loopClosureId(self) -> int: ...

    def loopClosureMapId(self) -> int: ...

    def proximityDetectionId(self) -> int: ...

    def proximityDetectionMapId(self) -> int: ...

    def stamp(self) -> float: ...

    def getLastSignatureData(self) -> Signature: ...

    def getSignaturesData(self) -> dict[int, Signature]: ...

    def poses(self) -> dict[int, Transform]: ...

    def mapCorrection(self) -> Transform: ...

    def loopClosureTransform(self) -> Transform: ...

    def localizationCovariance(self) -> numpy.array: ...

    def labels(self) -> dict[int, str]: ...

    def weights(self) -> dict[int, int]: ...

    def posterior(self) -> dict[int, float]: ...

    def likelihood(self) -> dict[int, float]: ...

    def rawLikelihood(self) -> dict[int, float]: ...

    def localPath(self) -> list[int]: ...

    def currentGoalId(self) -> int: ...

    def reducedIds(self) -> dict[int, int]: ...

    def wmState(self) -> list[int]: ...

    def odomCachePoses(self) -> dict[int, Transform]: ...

    def data(self) -> dict[str, float]: ...

class StereoCameraModel:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, name: str, imageSize1: tuple, K1: numpy.array, D1: numpy.array, R1: numpy.array, P1: numpy.array, imageSize2: tuple, K2: numpy.array, D2: numpy.array, R2: numpy.array, P2: numpy.array, R: numpy.array, T: numpy.array, E: numpy.array, F: numpy.array) -> None: ...

    @overload
    def __init__(self, name: str, leftCameraModel: CameraModel, rightCameraModel: CameraModel) -> None: ...

    @overload
    def __init__(self, name: str, leftCameraModel: CameraModel, rightCameraModel: CameraModel, extrinsics: Transform) -> None: ...

    @overload
    def __init__(self, fx: float, fy: float, cx: float, cy: float, baseline: float) -> None: ...

    @overload
    def __init__(self, name: str, fx: float, fy: float, cx: float, cy: float, baseline: float) -> None: ...

    def isValidForProjection(self) -> bool: ...

    def isValidForRectification(self) -> bool: ...

    def initRectificationMap(self) -> None: ...

    def isRectificationMapInitialized(self) -> bool: ...

    def setName(self, arg0: str, arg1: str, arg2: str, /) -> None: ...

    def name(self) -> str: ...

    def setImageSize(self, arg: tuple, /) -> None: ...

    def load(self, arg0: str, arg1: str, arg2: bool, /) -> bool: ...

    def save(self, arg0: str, arg1: bool, /) -> bool: ...

    def saveStereoTransform(self, arg: str, /) -> bool: ...

    def serialize(self) -> list[int]: ...

    def deserialize(self, arg: Sequence[int], /) -> int: ...

    def baseline(self) -> float: ...

    def computeDepth(self, arg: float, /) -> float: ...

    @overload
    def computeDisparity(self, arg: float, /) -> float: ...

    @overload
    def computeDisparity(self, arg: int, /) -> float: ...

    def R(self) -> numpy.array: ...

    def T(self) -> numpy.array: ...

    def E(self) -> numpy.array: ...

    def F(self) -> numpy.array: ...

    def scale(self, arg: float, /) -> None: ...

    def roi(self, arg: tuple, /) -> None: ...

    def setLocalTransform(self, arg: Transform, /) -> None: ...

    def localTransform(self) -> Transform: ...

    def stereoTransform(self) -> Transform: ...

    def left(self) -> CameraModel: ...

    def right(self) -> CameraModel: ...

    def getLeftSuffix(self) -> str: ...

    def getRightSuffix(self) -> str: ...

class Transform:
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, /) -> None: ...

    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, /) -> None: ...

    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, /) -> None: ...

    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, /) -> None: ...

    def clone(self) -> Transform: ...

    def r11(self) -> float: ...

    def r12(self) -> float: ...

    def r13(self) -> float: ...

    def r21(self) -> float: ...

    def r22(self) -> float: ...

    def r23(self) -> float: ...

    def r31(self) -> float: ...

    def r32(self) -> float: ...

    def r33(self) -> float: ...

    def o14(self) -> float: ...

    def o24(self) -> float: ...

    def o34(self) -> float: ...

    def isNull(self) -> bool: ...

    def isIdentity(self) -> bool: ...

    def size(self) -> int: ...

    def theta(self) -> float: ...

    def isInvertible(self) -> bool: ...

    def inverse(self) -> Transform: ...

    def rotation(self) -> Transform: ...

    def translation(self) -> Transform: ...

    def to3DoF(self) -> Transform: ...

    def to4DoF(self) -> Transform: ...

    def is3DoF(self) -> bool: ...

    def is4DoF(self) -> bool: ...

    def rotationMatrix(self) -> numpy.array: ...

    def translationMatrix(self) -> numpy.array: ...

    def getTranslationAndEulerAngles(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, /) -> None: ...

    def getEulerAngles(self, arg0: float, arg1: float, arg2: float, /) -> None: ...

    def getTranslation(self, arg0: float, arg1: float, arg2: float, /) -> None: ...

    def getAngle(self, arg: Transform, /) -> float: ...

    def getNorm(self) -> float: ...

    def getNormSquared(self) -> float: ...

    def getDistance(self, arg: Transform, /) -> float: ...

    def getDistanceSquared(self, arg: Transform, /) -> float: ...

    def interpolate(self, arg0: float, arg1: Transform, /) -> Transform: ...

    def normalizeRotation(self) -> None: ...

    def prettyPrint(self) -> str: ...

    def toEigen4f(self) -> Annotated[ArrayLike, dict(dtype='float32', shape=(4, 4), order='F')]: ...

    def toEigen4d(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(4, 4), order='F')]: ...

    @staticmethod
    def getIdentity() -> Transform: ...

    @staticmethod
    def fromEigen4f(arg: Annotated[ArrayLike, dict(dtype='float32', shape=(4, 4), order='F')], /) -> Transform: ...

    @staticmethod
    def fromEigen4d(arg: Annotated[ArrayLike, dict(dtype='float64', shape=(4, 4), order='F')], /) -> Transform: ...

    @staticmethod
    def opengl_T_rtabmap() -> Transform: ...

    @staticmethod
    def rtabmap_T_opengl() -> Transform: ...

    @staticmethod
    def fromString(arg: str, /) -> Transform: ...

    @staticmethod
    def canParseString(arg: str, /) -> bool: ...

    @staticmethod
    def getTransform(arg0: Mapping[float, Transform], arg1: float, /) -> Transform: ...

class VWDictionary:
    def __init__(self) -> None: ...

    def parseParameters(self, arg: Mapping[str, str], /) -> None: ...

    def update(self) -> None: ...

    def addNewWords(self, arg0: numpy.array, arg1: int, /) -> list[int]: ...

    def addWord(self, arg: VisualWord, /) -> None: ...

    def findNN(self, arg: numpy.array, /) -> list[int]: ...

    def addWordRef(self, arg0: int, arg1: int, /) -> None: ...

    def removeAllWordRef(self, arg0: int, arg1: int, /) -> None: ...

    def getWord(self, arg: int, /) -> VisualWord: ...

    def getUnusedWord(self, arg: int, /) -> VisualWord: ...

    def setLastWordId(self, arg: int, /) -> None: ...

    def getVisualWords(self) -> dict[int, VisualWord]: ...

    def getNndrRatio(self) -> float: ...

    def getNotIndexedWordsCount(self) -> int: ...

    def getLastIndexedWordId(self) -> int: ...

    def getTotalActiveReferences(self) -> int: ...

    def getIndexedWordsCount(self) -> int: ...

    def getIndexMemoryUsed(self) -> int: ...

    def getMemoryUsed(self) -> int: ...

    def setNNStrategy(self, arg: NNStrategy, /) -> bool: ...

    def isIncremental(self) -> bool: ...

    def isIncrementalFlann(self) -> bool: ...

    def setIncrementalDictionary(self) -> None: ...

    def setFixedDictionary(self, arg: str, /) -> None: ...

    def isModified(self) -> bool: ...

    def serializeIndex(self) -> list[int]: ...

    def deserializeIndex(self, arg: Sequence[int], /) -> None: ...

    def exportDictionary(self, arg0: str, arg1: str, /) -> None: ...

    def clear(self, arg: bool, /) -> None: ...

    def getUnusedWords(self) -> list[VisualWord]: ...

    def getUnusedWordIds(self) -> list[int]: ...

    def getUnusedWordsSize(self) -> int: ...

    def removeWords(self, arg: Sequence[VisualWord], /) -> None: ...

    def deleteUnusedWords(self) -> None: ...

    def convertBinTo32F(self, arg: bool, /) -> numpy.array: ...

    def convert32FToBin(self, arg: bool, /) -> numpy.array: ...

class VisualWord:
    def __init__(self, id: int, descriptor: numpy.array, signatureId: int = 0) -> None: ...

    def addRef(self, arg: int, /) -> None: ...

    def removeAllRef(self, arg: int, /) -> int: ...

    def getMemoryUsed(self) -> int: ...

    def getTotalReferences(self) -> int: ...

    def id(self) -> int: ...

    def getDescriptor(self) -> numpy.array: ...

    def getReferences(self) -> dict[int, int]: ...

    def isSaved(self) -> bool: ...

    def setSaved(self, arg: bool, /) -> None: ...
